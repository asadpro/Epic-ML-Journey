[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Machine Learning Foundations: A Comprehensive Guide from Python to Mathematics",
    "section": "",
    "text": "Preface\nThis book is for those who are fully beginner and want to learn how can they become master in machine learning from no-coding experience to become proficient ML Engineer of the future. This is not just a book but a journey of a machine learning engineer and what he learn and explore throughout his journey from going python to advanced topic like deep learning algorithm and the mathematics behind it. So be patience and read it step-by-step and you will be rewarded with the knowledge that will make you from ordinary to extra-ordinary person Inshallah!.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#attention-to-details",
    "href": "index.html#attention-to-details",
    "title": "Machine Learning Foundations: A Comprehensive Guide from Python to Mathematics",
    "section": "Attention to Details",
    "text": "Attention to Details\nKey that differ a bad program from a good one is to attention to the detail of the problem. In fact, its applies to every proficient. Those who aren’t paying attention may end up with a lot of buggy code and will not be able to solve it proficiently and will always do dwelling on internet to solve only a simple problem.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#do-not-copy-paste",
    "href": "index.html#do-not-copy-paste",
    "title": "Machine Learning Foundations: A Comprehensive Guide from Python to Mathematics",
    "section": "Do Not Copy-Paste",
    "text": "Do Not Copy-Paste\nDo not copy-paste any of the coding example. Practice it by yourself and play around with it a little bit, Tweak it so that you understand how it works.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#a-note-for-smarties",
    "href": "index.html#a-note-for-smarties",
    "title": "Machine Learning Foundations: A Comprehensive Guide from Python to Mathematics",
    "section": "A Note for Smarties",
    "text": "A Note for Smarties\nIf any of the reader think that i am insulting him then don’t read this book because its for those who is beginner and want to start their career in machine learning or Artificial Inteligence. If you know everything then perhaps you should learn Lisp, which stands for (List Processing) programming language. I hear people who know everything really like Lisp.\n\n\n\n\n\n\nNote\n\n\n\n\n\nEngaging in real-world problem-solving and delving into research requires a significant time commitment.\n\n\n\n\nLet’s start from here…",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "1. python basics/about author.html",
    "href": "1. python basics/about author.html",
    "title": "About the Author",
    "section": "",
    "text": "Photo Of Author\n\n\n\nSaeed Ullah is a dynamic individual with a passion for technology, science, and the intricate dance between code and creativity. Hailing from Pakistan, Saeed Ullah is a dedicated computer science student, avid gardener, and aspiring robotic engineer. His insatiable curiosity extends beyond the realms of his formal studies, as he continuously seeks to broaden his knowledge across various disciplines.\nWith a background in electrical engineering and a focus on mastering machine learning, mathematics, and computer programming, Saeed Ullah is on an epic journey through the landscapes of emerging technologies. He finds joy in the fusion of theoretical concepts and hands-on application, always eager to contribute to the cutting edge of science and technology.\n\n\nBeyond the world of algorithms and circuits, Saeed Ullah is a green-thumbed enthusiast, nurturing a garden that reflects both patience and growth—a metaphor that echoes his approach to life and learning.\nIn this book, Saeed Ullah shares not only technical insights but also the spirit of exploration and the pursuit of excellence. Through the lens of his experiences and expertise, readers are invited to join him on a journey where technology meets creativity, and the possibilities are as vast as the ever-expanding universe of knowledge.\n\n\n\nPhoto Of Author",
    "crumbs": [
      "About the Author"
    ]
  },
  {
    "objectID": "1. python basics/setup.html",
    "href": "1. python basics/setup.html",
    "title": "Windows OS Setup",
    "section": "",
    "text": "Install Python from the following link or watch any YouTube video on it to install it as it requires only vs code (editor) and Python language installation: Certainly, Asad_Pro_3.1. Here’s a paraphrased version of the instructions:\n\nVisit Notepad++, download the Notepad++ text editor and install it without requiring administrator privileges.\nEnsure easy access to Notepad++ by placing shortcuts on your desktop and/or in Quick Launch during the installation.\nLaunch PowerShell from the Start menu by searching for it and pressing Enter.\nCreate shortcuts for PowerShell on your desktop and/or Quick Launch for convenience.\nOpen your Terminal program, and if Python is not recognized, install it from Python.\nConsider using ActiveState Python if administrative rights are an issue. If Python isn’t recognized after installation, set the environment variable in PowerShell and restart it.\n\n\n\nIf you run Python and it’s not there (python is not recognized.), install it from http://python.org/download.\nMake sure you install Python 2, not Python 3.\nYou may be better off with ActiveState Python, especially if you do not have administrative rights.\nIf after you install it python still isn’t recognized, then in PowerShell enter this: [Environment]::SetEnvironmentVariable(“Path”, “$env:Path;C:”, “User”)\nClose PowerShell and then start it again to make sure Python now runs. If it doesn’t, restart may be required.\n\n\n\nType quit() in Python to exit.\nReturn to the previous prompt in the Terminal and troubleshoot if necessary.\nLearn how to create a directory in the Terminal.\nFamiliarize yourself with changing directories in the Terminal.\nUtilize your text editor to create a file in the directory, then save it.\nSwitch back to the Terminal using keyboard shortcuts.\nIn the Terminal, check if you can list the directory to confirm the creation of your new file.",
    "crumbs": [
      "Windows OS Setup"
    ]
  },
  {
    "objectID": "1. python basics/1-python basics.html",
    "href": "1. python basics/1-python basics.html",
    "title": "1  Introduction to Python",
    "section": "",
    "text": "1.1 Python Basics:\nOpen the search bar and open one of the following:\nRun your Python script in the directory where you have stored your .py python file just open cmd there and run the command: python filename.py",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Python</span>"
    ]
  },
  {
    "objectID": "1. python basics/1-python basics.html#python-basics",
    "href": "1. python basics/1-python basics.html#python-basics",
    "title": "1  Introduction to Python",
    "section": "",
    "text": "Command Prompt (cmd) for short.\nPowerShell\nIDLE Python shell\nOpen your favorite Editor and write the following code into it and then save it as hello.py (python programs can be run only if they are in .py extension)\n\n\n\n1print(\"Yay! i am writing my first program\")\n2print('i am printing')\n3('' , \"\")\n\n1\n\nprint is called a function which will be explained in the letter chapters. so don’t stuck on this programming lingo for now.\n\n2\n\nAs you can see between those yellow brackets, text can be enclosed in both single and double quotes.\n\n3\n\nThese quotes tell Python that we are writing strings and strings are like plain text to Python, it’s that simple.\n\n\n\n\n\n\n\n\nTip\n\n\n\nAlso, run your code in Python Visual Compiler which explains and runs your code step by step to show you what happens under the hood. Here’s the link: Python Visual Compiler\n\n\n\n1.1.1 Comments in Python\nComments are used to tell what the specific part of your program does and it’s like an instruction box for your line of code. It can also be used to disable your code. so this it won’t run.\n\n1print('printing nothing') #single line comment\n\n2'''Multiline comments'''\n\n1\n\nThis is a single line of comment. Here with pound character, I can write anything just to explain this piece of code not to execute it\n\n2\n\nYou can also use multiline comments with the help of 3 single quotes which are used to write multiple lines without specifying any # hash or pound character every time you start a new line of text.\n\n\n\n\n1.1.2 Numbers & Math in Python\n\nMost Commonly used Mathematics symbols\n\n\nSymbols\nNames\n\n\n\n\n+\nPlus\n\n\n-\nMinus\n\n\n/\nSlash\n\n\n*\nAsterisk\n\n\n%\nPercent\n\n\n&lt;\nLess-than\n\n\n&gt;\nGreater-than\n\n\n&lt;=\nLess-than-equal\n\n\n&gt;=\nGreater-than-equal\n\n\n\n\n\n1.1.3 Variable & Names\nFirst, let’s understand Variable in simple terms:\nImagine you have a box, and you give it a name, like number_box Now, you can put a number in it, let’s say 5. So, number_box holds the value 5.\nnumber_box = 5\nHere number_box is the variable and the number 5 is the value in it. You can also change it like below\nnumber_box = 10\nprint(number_box) # Output: 10\nNow it contains 10 instead of 5. Variables are useful and it lets you store and keep track of your numbers text and several other things you will see in the advanced sections.\nQuiz time:\n\nQuestion 1: Write a Python code snippet to print the phrase “Hello, Python!”\n\n\nQuestion 2: How can you print the result of multiplying two numbers, let’s say 4 and 7, in Python?\n\n\nQuestion 3: Explain what the end parameter in the print function is used for.\n\n\nQuestion 4: Write a Python code snippet to print your name on one line and your age on the next line.\n\n\nQuestion 5: If you want to print the following text on separate lines:\n\nProgramming\nis\nfun!\nHow would you achieve this using the print function?\n\n\n\n\n\n\nClick to see answers…\n\n\n\n\n\n\nprint(\"Hello, Python!\")\nprint(4 * 7)\nThe end parameter in the print function is used to specify the character that separates multiple printed items. By default, it is set to \\n, which means a newline character. Newline is like when we reach the end of a line we press enter that’s exactly what do, just to press enter at the end of a line.\nprint(\"Your Name\")\nprint(\"Your Age\")\nprint(\"Programming\")\nprint(\"is\")\nprint(\"fun!\")\n\n\n\n\nString formating\nWe can also format our string output in different ways, First I will write code and then from following you can see its explanation below:\n\nmy_name = 'Asad Pro Beta' # My digital persona \naddress = 'Peshawar, Pakistan'\nmy_age = 35 # Just kidding\nmy_height = 74 # inches\n\n1print(my_name+' ',address)\n2print(my_name+3*'.')\n3print('Your name is: {} my age: {}'.format(my_name,my_age))\n4print('Your age is: {1} my name: {0}'.format(my_name, my_age))\n5print(f'Your name is: {my_name} my age: {my_age}')\n6print(r'Your name is: {my_name} my age: {my_age}')\n\n1\n\nThis + sign merges (concatenates) two strings together and that white space separates them\n\n2\n\nFirst multiply the dot with 3 which becomes (…) & then concatenate (merge) it with that string (my_name)\n\n3\n\nThe format function in Python is like a template for creating sentences where you want to replace certain parts with specific values. Let me explain with an analogy: Imagine you have a fill-in-the-blank storybook. The storybook has sentences with blanks, and you have stickers with words on them. Each sticker has a different word that fits into one of the blanks.\n\n4\n\nWe can also use index numbers, Index are like the address of every variable where stored on computer memory.\n\n5\n\nPutting f in the beginning acts as a format function with which it identifies variables.\n\n6\n\nPutting r in the beginning means that this string is raw which means nothing in other words, print everything as it is.\n\n\n\n1A,B,C,D,E = [i for i in range(ord('A'),ord('E')+1)]\na,b,c,d,e = [i for i in range(ord('a'),ord('e')+1)]\n\n\n2print(A,B,C,D,E,\n      a,b,c,d,e)\n\n3A, B, C, D, E = [65, 66, 67, 68, 69]\n\ndays = \"Mon Tue Wed Thu Fri Sat Sun\"\n4months = \"Jan\\nFeb\\nMar\\nApr\\nMay\\nJun\\nJul\\nAug\"\n\nprint(days)\nprint(months) \n\n1\n\nThis is another way to assign a list of values to multiple variables at once. (Don’t bother we will cover Lists in later chapters)\n\n2\n\nRemove that comma after ‘E’ and see what happens\n\n3\n\nIt’s the same as the first one above, I have just created the list dynamically in the first place.\n\n4\n\nHere you will see that the \\n character will act as an enter and printing will start from the new line. Copy and paste it into your editor and see its result on your own.\n\n\n\n\n\n\n\n\nClick to explore print function thoroughly\n\n\n\nMore on print\n\n\n\n\n1.1.4 Escape Sequences\nImagine you’re writing a story on the computer, and you want to do some special things with your words. Escape sequences in Python are like magic codes you can use to make your words look different or do special tricks!\nLook at the following table and try them out on your own:\n\n\n\n\n\n\n\nEscape\nWhat it does\n\n\n\n\n\\\\\nBackslash ()\n\n\n\\'\nSingle-quote (’)\n\n\n\\\"\nDouble-quote (“)\n\n\n\\a\nASCII bell (BEL)\n\n\n\\b\nASCII backspace (BS)\n\n\n\\f\nASCII formfeed (FF)\n\n\n\\n\nASCII linefeed (LF)\n\n\n\\N{name}\nCharacter named name in the Unicode database\n\n\n\\r\nASCII carriage return (CR)\n\n\n\\t\nASCII horizontal tab (TAB)\n\n\n\\uxxxx\nCharacter with 16-bit hex value xxxx (Unicode only)\n\n\n\\Uxxxxxxxx\nCharacter with 32-bit hex value xxxxxxxx (Unicode only)\n\n\n\\v\nASCII vertical tab (VT)\n\n\n\\ooo\nCharacter with octal value oo\n\n\n\\xhh\nCharacter with hex value hh\n\n\n\nPrompting People or Asking for Input\nprint('How old are you?') \nage =  input()\nprint(f'Your age : {age}')\ninput() is a method that shows you an empty placeholder for you to insert any value & when you insert then press enter so that the value can be stored in the age variable.\n\nInput() function is like an empty page; someone gives you and you write anything that comes to your mind.\n\n\nHere, we have used the same string formatting as we used earlier.\n\n\n\n1.1.5 Python modules\nLet’s see the code first…\n1import os\n2current_path = os.getcwd()\nprint(current_path)\n\n1\n\nos is a built-in module of Python that is used to do local operating system level operations like directory change, the path of the folder navigating through directories etc.\n\n2\n\nThis code just copies the path where you are running your file. Don’t confuse yourself with that os.getcwd() for now you will soon understand this.\n\n\n\n\n\n\n\n\nModule in simple terms\n\n\n\nThink of these modules OS this way. If Python is an electrician then modules are its tool sets with every tool having its specific purpose (pliers, voltage tester, wire stripper, multimeter etc) or you can say these modules are the features of Python.\n\n\nAsking Prompt and Passing Argument\nfrom sys import argv\nscript_name, username = argv\nprint(f'Script name: {script_name}')\nprint(f'Username: {username}')\n\n'''\nInput:   python delete.py asad\nOutput:  Script name: delete.py\n         Username: Asad\n'''\n\nThis is the other way to import a module(feature) which says import from the module sys the argv method (which is a small part of that module)\nFirst open the terminal and navigate to your file where it is stored then run python delete.py asad here delete.py is my python file name write what’s yours and asad is the argument like an extra input to catch it inside our program.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Python</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html",
    "href": "1. python basics/2-flow control.html",
    "title": "2  Flow Control",
    "section": "",
    "text": "2.1 Boolean Values\nWhile string, integer & floating numbers can have an infinite number of possible values, the Boolean data type has only 2 values True or False. They would always start with capital T or F with the rest of the words in lowercase. Practice the following code into the shell:",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#boolean-values",
    "href": "1. python basics/2-flow control.html#boolean-values",
    "title": "2  Flow Control",
    "section": "",
    "text": "defect = True\ndefect # Output: True\n\ndefect = False\ndefect # Output: False\n\n2+2 == 4 # Output: True\n\n1True = 4+5 # will give you SyntaxError: can't assign to keyword\n\n1\n\nYou can’t use keyword as a variable check on keyword more",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#comparison-operators",
    "href": "1. python basics/2-flow control.html#comparison-operators",
    "title": "2  Flow Control",
    "section": "2.2 Comparison Operators",
    "text": "2.2 Comparison Operators\nComparison operator aka relational operators. These are used to compare two expressions and evaluate them to a single Boolean value.\n\nList of most commonly used comparison operators\n\n\nOperator\nMeaning\n\n\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal to\n\n\n&gt;=\nGreater than or equal to\n\n\n\nOpen Python Shell by pressing Win+RWin+R & write python press EnterEnter:\n23 == 32\n23 != 43\n43 &lt; 234\n43 &gt; 23\n54 &lt;= 54\n66 &gt;= 77\n\n'hi' == 'hi'\n1'Hello' == 'hello'\nTrue == True\n242 == 42.0\n39124 == '9124'\n49124 == int('9124')\n\n1\n\nThis will return False because the first character of both is different in the context of programming and both have separate representations in binary on memory.\n\n2\n\nBoth are the same but if you write 42.0 as 42.1 then it will return False and will it bigger than only 42.\n\n3\n\nOne is an integer and the other is a string so both have different data types and different meanings.\n\n4\n\nThe int() function will take 9124 as a string and will convert it into an integer and then it will be compared with 9124, which will return True.\n\n\n\n\n\n\n\n\nDifference Between == & = Operators\n\n\n\nThe == operator is used to compare two things whether they are the same or not.  The = operator is used to assign a value to the variable.\n You will learn more about this later once you understand flow control statements.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#boolean-operators",
    "href": "1. python basics/2-flow control.html#boolean-operators",
    "title": "2  Flow Control",
    "section": "2.3 Boolean Operators",
    "text": "2.3 Boolean Operators\nThree Boolean operators (and, or, & not) are used to compare boolean values. Let’s see its truth tables\n\n\n\n\n\n\n\nAND Truth Table\n\n\nExpression\nOutput\n\n\n\n\nTrue and True\nTrue\n\n\nTrue and False\nFalse\n\n\nFalse and True\nFalse\n\n\nFalse and False\nFalse\n\n\n\n\n\n\nOR Truth Table\n\n\nExpression\nOutput\n\n\n\n\nTrue or True\nTrue\n\n\nTrue or False\nTrue\n\n\nFalse or True\nTrue\n\n\nFalse or False\nFalse\n\n\n\n\n\n\nNOT Truth Table\n\n\nExpression\nOutput\n\n\n\n\nnot True\nFalse\n\n\nnot False\nTrue",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#mixed-up-boolean-and-comparison-operators",
    "href": "1. python basics/2-flow control.html#mixed-up-boolean-and-comparison-operators",
    "title": "2  Flow Control",
    "section": "2.4 Mixed up Boolean and Comparison Operators",
    "text": "2.4 Mixed up Boolean and Comparison Operators\nNow let’s see it by practicing it in the interactive shell of Python:\n1&gt;&gt;&gt; (5 &gt; 4) and (7 &lt; 9)\nTrue\n2&gt;&gt;&gt; (23 &lt; 22) or (32 &gt; 23)\nTrue\n3&gt;&gt;&gt; not (5 &gt; 1)\nFalse\n\n1\n\nThe interpreter will start from the left and go to the right such as (5 &gt; 4) return True and then the second expression will return True then if you see the truth table of AND above you will see its outcome.\n\n2\n\nThe same goes for or gate where the first expression is False and the second expression returns True which is also True\n\n3\n\nnot negate the boolean value so (5 &gt; 1) is True but then the not operator will make it False\n\n\n\n\n\n\n\n\nNote\n\n\n\nFlow control statements have 2 parts called the condition and are always followed by a block of code called clause.\n\nif police == True: # Condition \n   print('Police is coming to catch the thief.') # Clause or Body\n   print('Help police in catching thief.')\n\n\nAll flow control statements end with a colon and are followed by a new block of code or clause.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#if-and-else-statements",
    "href": "1. python basics/2-flow control.html#if-and-else-statements",
    "title": "2  Flow Control",
    "section": "2.5 if and else Statements",
    "text": "2.5 if and else Statements\nAn if condition will execute if it’s true followed by its body block of code. If it’s false then optionally there is an else clause to execute (else block is optional you can omit it as well.)\nIn simple words you can say that “If you work hard you will succeed else you will become looser”\nLet’s practice:\n&gt;&gt;&gt; if work == 'hard':\n...     print('Made him succeed')\n... else:\n...     print('Made him looser')\n...\nMade him succeed # Output",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#elif-statements",
    "href": "1. python basics/2-flow control.html#elif-statements",
    "title": "2  Flow Control",
    "section": "2.6 elif statements",
    "text": "2.6 elif statements\nWe also have an else if statement in short elif it allows you to include multiple conditions. Check it below in practice:\nage = 25\nif age == 5:\n    print('You are not old enough to watch movies')\nelif age == 18:\n    print('You can watch 16+ movies')\nelif age == 23:\n    print('You are old enough to watch extreme horror movies')\nelse:\n    print('You mature enough to care after your family')\n\nYou mature enough to care after your family # Output",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#while-loop",
    "href": "1. python basics/2-flow control.html#while-loop",
    "title": "2  Flow Control",
    "section": "2.7 While Loop",
    "text": "2.7 While Loop\nA while loop is a control flow structure in programming that repeats a block of code while a certain condition is true. It continues executing the code as long as the specified condition remains true.\nHere’s a simple explanation and example in Python:\nExplanation:\nA while loop checks a condition before each iteration. If the condition is true, the code inside the loop is executed. After each iteration, the condition is checked again. The loop continues until the condition becomes false.\n# Initialize a variable\ncounter = 1\n\n# Define the condition\nwhile counter &lt;= 5:\n    # Code inside the loop\n    print(counter) # \n    \n    # Update the counter for the next iteration\n    counter += 1\nExplanation of the Example:\n\nWe start with the counter set to 1.\nThe condition counter &lt;= 5 is true, so we enter the loop and print the value of the counter.\nWe increment the counter by 1 (using counter += 1) to move to the next number.\n\n\n\n\n\n\n\nWarning\n\n\n\nWhile loop may also crash your program while giving it such a condition which never meant to end like the one below:\nwhile True:\n   print('This loop will never end.')\n\n\n\n\n\n\n\n\nTrapped in an infinite loop\n\n\n\n\n\nIf you ever find yourself trapped in the infinite loop then simply press CTRL+CCTRL+C. This will send a KeyboardInterrupt error to your program and will halt the execution of your program.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#break-statement",
    "href": "1. python basics/2-flow control.html#break-statement",
    "title": "2  Flow Control",
    "section": "2.8 Break Statement",
    "text": "2.8 Break Statement\nNow if you fear not to stuck in the infinite loop then there is the solution to this which is the break statement. Place it in a place where you want to exit the execution of a program e.g. Run the following code in the interactive shell.\nwhile True:\n   print('This loop will break')\n1   break\n\n1\n\nThis break statement will terminate the flow of the while loop.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#continue-statement",
    "href": "1. python basics/2-flow control.html#continue-statement",
    "title": "2  Flow Control",
    "section": "2.9 Continue statement",
    "text": "2.9 Continue statement\nSimilar to the break statement, we also have a continue statement which lets you jump back to the start of the loop. Let’s try it in the interactive shell:\nwhile True:\n   print('who are you?')\n   name = input()\n   if name != 'asad':\n            continue\n   print(f'your name is {name}')\n   break",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#for-loop",
    "href": "1. python basics/2-flow control.html#for-loop",
    "title": "2  Flow Control",
    "section": "2.10 For loop",
    "text": "2.10 For loop\nSo far, We have seen the while loop but if want the loop to execute a certain number of times, for that we have for loops. imagine you have a backpack full of books, and you want to know what’s inside each book. A for loop is like flipping through each book one by one and checking the pages. You keep doing this until you’ve looked through all the books in your backpack.\n# Imagine your backpack is like a list of books\nbackpack = [\"Adventure Book\", \"Science Book\", \"Mystery Book\", \"Comic Book\"]\n\n# Using a for loop to check each book\nfor book in a backpack:\n    # Code inside the loop\n    print(\"Checking the pages of\", book)\n\n# After the loop, you've checked every book in your backpack!\nIn this example:\n\nbackpack is like your list of books.\nThe for loop is like going through each book (Adventure Book, Science Book, etc.) in your backpack, one after the other.\nThe code inside the loop (printing “Checking the pages of [book]”) is like looking through the pages of each book.\nAfter the loop, you’ve checked every book in your backpack.\n\n\n2.10.1 Range() function\nThe range function is used to specify the number of iterations dynamically to the loop so it won’t go beyond that limit e.g. Let’s stick to the previous example:\nbackpack = [\"Adventure Book\", \"Science Book\", \"Mystery Book\", \"Comic Book\"]\n\n1for i in range(len(backpack))\n2   print(backpack[i])\n\n1\n\nThe len() function returns the number of elements in the list which is 5, so it would start from 0 and go to the length of that list (5).\n\n2\n\nHere, in the first iteration i would be 0 so it will fetch the first element of the list.\n\n\nDon’t worry, We will see the lists in detail later.\n\n\n2.10.2 Start, Stop & Step Arguments to range()\nWe can also pass arguments to the functions & arguments are like giving superpower to that function. Look it in practice:\n1for i in range(1, 10, 2): # (start, stop, step)\n   print(i)\n   Output: 1, 3, 5, 7, 9\n\n1\n\nThis says, Start from 1 and go till 10 but skip 2 digits between and print the third digit.\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can also use a negative number in the step argument to make the for go from up to down.\nfor i in range(0, -10, -1): \n   print(i)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#importing-modules",
    "href": "1. python basics/2-flow control.html#importing-modules",
    "title": "2  Flow Control",
    "section": "2.11 Importing modules",
    "text": "2.11 Importing modules\nThe module is a Python program made by a third party to use it for your task. Python also comes with built-in modules called standard libraries. Each module is a set of Python programs that can be embedded in your programs. For example, the math module is used to do all the mathematical operations and the random module has random-number-related functions.\nBefore you use the module, you must import it into your Python file in the following format:\n1import random\nfor i in range(4):\n   print(random.randint(50,100))\n\n2import random, os, math, sys\n\n1\n\nImport the random module and give us 4 random numbers b/w 50-100.\n\n2\n\nYou can import multiple modules as long as every module name is separated by a comma.\n\n\n:::{.callout-caution title=” DON’T OVERWRITE MODULE NAMES”} If you save your Python file with the same name you used in the import statement like random.py or math.py this will import the Python file you have created instead of the Python module. :::",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#from-import-statements",
    "href": "1. python basics/2-flow control.html#from-import-statements",
    "title": "2  Flow Control",
    "section": "2.12 from import statements",
    "text": "2.12 from import statements\nAs you see in the above example we have imported the whole module which contains several functions within it, but sometimes we want a single function from that module, like if we want to use only the randint() function, then we can do this by: from random import randint\nThe above statement will only import the randint function and you cannot use other functions of the random module. This way you save a lot of memory from importing any unnecessary functions from that random module & use only the required one.\nYou can also import multiple functions like: from random import randint, choice, shuffle",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/2-flow control.html#ending-a-program-before-time",
    "href": "1. python basics/2-flow control.html#ending-a-program-before-time",
    "title": "2  Flow Control",
    "section": "2.13 Ending a Program Before Time",
    "text": "2.13 Ending a Program Before Time\nThe program always terminates once it reaches the bottom of the program execution. However, if you want the program to terminate early you can use the following module & its function.\nimport sys\n\nwhile True:\n   for i in range(5):\n      print(i)\n   sys.exit()\n\n\n\n\n\n\nAnswer to Curious Individual\n\n\n\nNow, you will say why not use a break statement rather than sys.exit()? Because the break statement lets you break out of the loop and the remaining program continues to execute conversely sys. exit() is used to terminate the execution of the whole program.\n\n\n\n2.13.1 Guess the Number Quiz\nWrite a program and ask the user to guess the number between 1-10.\n\n\n\n\n\n\nClick to See the Solution Code\n\n\n\n\n\nimport random\n\nrand_number = random.randint(1,10)\nprint('Guess the number between 1-10: ')\nanswer = False\n\nwhile answer!=True:\n   response = int(input('Take a guess: '))\n   \n   if response &lt; rand_number:\n      print('You guess too low')\n\n   elif response &gt; rand_number:\n      print('You guess too high')\n\n   else:\n      answer = not answer   \n      print('You guessed it right')\n      print(f'System guess: {rand_number}\\nUser guess: {response}')\n\n\n\n\n\n\nThis is how Flow Control Works in Programming",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flow Control</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html",
    "href": "1. python basics/3-functions.html",
    "title": "3  Functions",
    "section": "",
    "text": "3.1 Functions with Arguments\nWhen you pass the string to the print() function between parenthesis is called the arguments. Think of an argument as an extra set of powers a function can have. Let’s look at the following analogy: Imagine you have a Robot friend and you want to give it 2 numbers to add them and give you the result. Every time you give it different numbers and will give you the sum of it.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#functions-with-arguments",
    "href": "1. python basics/3-functions.html#functions-with-arguments",
    "title": "3  Functions",
    "section": "",
    "text": "# Copy and Paste it into your shell window to see its output:\n\n1def robot(num1 , num2):\n    print(num1 + num2)\n\n2robot(23, 42)\nrobot(3, 2)\nrobot(33, 12)\n\n1\n\nnum1 & num2 are parameters (which is an empty Box)\n\n2\n\n23 & 42 are the arguments that will go inside the num1 & num2 parameters.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#the-none-value",
    "href": "1. python basics/3-functions.html#the-none-value",
    "title": "3  Functions",
    "section": "3.2 The None Value",
    "text": "3.2 The None Value\nIn Python, we have a value called None which represents nothing or the absence of a value. The None keyword must be started with capital ‘N’. None is the only data type of the NoneType class. (will explain later what are classes)\ndef func_none(response):\n    if response == 'Gold' or response == 'Silver':\n        print('You Got Gold!!')\n    elif response == 'Gold' or response == 'Silver':\n        print('You Got Gold!!')\n    else:\n        return func_none\n\n1result = func_none(response=input('Choose Gold or Silver, If you choose anything else you will get \"None\" '))\n\n2print(result)\n\n1\n\nHere, the program will ask the user to enter the value and that value will be passed to the func_none() function as an argument and there the condition would be applied to the corresponding value if none of the conditions met, then the function returns the None value.\n\n2\n\nHere, if func_none() returns the result of the condition met like “Gold” or “Silver” then in the second line it would also print None and that’s because print() function on itself return nothing which is basically None.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#local-and-global-scope",
    "href": "1. python basics/3-functions.html#local-and-global-scope",
    "title": "3  Functions",
    "section": "3.3 Local and Global Scope",
    "text": "3.3 Local and Global Scope\nLet’s look at the code first and then we will see what is Local and Global.\n1name = 'asad'\n\ndef func1():\n    name = 'wafi'\n2    print(name)\n\ndef func2():\n    age = 18\n3    print('Name: ',name)\n    print('Age: ',age)\n\nfunc1() \nfunc2() \n\n1\n\nHere, the name variable can be accessed everywhere in the same program file e.g. func1.py while the name variable inside the func1() function can only be accessed inside that function.\n\n2\n\nGives you wafi` in output.\n\n3\n\nHere the name variable will return the value ‘asad’ from the Global scope.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#global-statement",
    "href": "1. python basics/3-functions.html#global-statement",
    "title": "3  Functions",
    "section": "3.4 Global Statement",
    "text": "3.4 Global Statement\nIf you want to modify the Global variable inside a function you can use the global keyword before that variable but do not create a variable with the same name as the Global variable inside that function.\n# Global variable\ncounter = 5\n\ndef increase_counter():\n    global counter\n    counter += 1\n\n# Before calling the function\nprint(\"Before: Counter =\", counter)\n\n# Calling the function to modify the global variable\nincrease_counter()\n\n# After calling the function\nprint(\"After: Counter =\", counter)\n\n\n\n\n\n\nNote\n\n\n\nIf you ever wanted to change the value of the Global variable you must use the global statement on the variable. So that Python knows which variable you are referring to.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#exception-handling",
    "href": "1. python basics/3-functions.html#exception-handling",
    "title": "3  Functions",
    "section": "3.5 Exception Handling",
    "text": "3.5 Exception Handling\nGetting an error or exception, in your Python programs means that the entire program will crash, But we don’t want this to happen in real-world scenarios, rather than you want the program to detect the error handle them and continue afterward.\nFor instance, run the following code in the editor:\ndef division(divider):\n    print(42 / divider)\n\ndivision(2) # Passing argument 2 to the function.\ndivision(7)\n1division(0)\ndivision(1)\n\n1\n\nHere when you pass 0 dividers to the division() function means you are dividing 42 by 0 which will give you an error like the one below:\n\n\n\nprint(42 / divider)\n\n1ZeroDivisionError: division by zero\n\n1\n\nZeroDivisionError is an exception raised by an error of dividing the number by zero.\n\n\nNow to prevent such types of exceptions & errors, Python has try and except clauses. The code that causes the error will go inside the try clause and the code that prevents the program from crashing goes into the except clause.\nFor example, Look at the above code with try and except clause:\n\ndef division(divider):\n    try:\n        print(42 / divider)\n1    except ZeroDivisionError:\n        print('You cannot divide with Zero')\n\n\n2division(0)\n\n1\n\nZeroDivisionError tells Python if you encounter ZeroDivisionError raise the following print message But you can write anything below except clause.\n\n2\n\nNow when you call the division function with 0 number it won’t crash the entire program but will give you a decent error message and the program will continue to execute other remaining instructions.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/3-functions.html#zigzag-program-for-fun",
    "href": "1. python basics/3-functions.html#zigzag-program-for-fun",
    "title": "3  Functions",
    "section": "3.6 ZigZag Program for Fun:",
    "text": "3.6 ZigZag Program for Fun:\nLet’s use your previous knowledge of programming to create a small animation zigzag program. Type the following code into your file editor & save the file as zigzag.py:\n2import time\nimport sys\n\ntry:\n1    while True:\n        counter = 4\n\n        for i in range(10):\n\n            if i &lt;= 4:\n                print(f'{counter*\" \"}********')\n                counter -= 1\n            elif counter == -1 or counter == 0:\n                counter = 1\n            else:\n                print(f'{\" \"*counter}********')\n                counter += 1\n\n3            time.sleep(0.3)  # Adjust the delay time as needed to make it more like animation\nexcept KeyboardInterrupt:\n    sys.exit()\n\n1\n\nThe while loop will never exit until you press Ctrl+cCtrl+c which calls the KeyboardInterrupt Error.\n\n2\n\nIn Python, the time module helps you work with time-related functions. It’s like a toolbox with tools to handle time-related tasks.\n\n3\n\nTry to write a program without try and except which will cause the program to crash if you want to stop the while loop by Ctrl+cCtrl+c and will give you an ugly error message. However, for our program we it to cleanly handle KeyboardInterrupt in except clause then pressing Ctrl+cCtrl+c won’t crash the program rather it will stop smoothly as usual by calling the sys.exit() function.\n\n\n\n\n\n\n\n\nSummary\n\n\n\nFunctions are the primary way to prevent you from duplicating your code. Functions are great to help you organize your code. You can think of it as the black boxes: they have input in the form of parameters and have output in the form of return values.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html",
    "href": "1. python basics/4-lists.html",
    "title": "4  Lists",
    "section": "",
    "text": "4.1 Getting Values in a List with Indexes\nSay you have a list ['red', 'blue', 'green', 45, True] stored in a variable named colors. If we want to access elements from this list we have to access it by its index (index is like the address of that item on the memory). e.g. colors[0] would return red and so on. Since list indexing starts with 0 that’s why to access the 5th element of the list you have to give it 4 or len(list)-1 less than one of the total length of the list.\nWe can also use negative indexing to display the list in reverse order or to iterate on the list from backward.\nFor example, try the following in the interactive shell.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#getting-values-in-a-list-with-indexes",
    "href": "1. python basics/4-lists.html#getting-values-in-a-list-with-indexes",
    "title": "4  Lists",
    "section": "",
    "text": "Source: https://www.dataquest.io\n\n\n\ncolors = ['blue','green','red','brown','white', 9124, True, False, 9.33]\n\ncolors = ['blue','green','red','brown','white', 9124, True, False, 9.33]\ncolors[0]\n'blue'\n1colors[-1]\n9.33\ncolors[-2]\nFalse\ncolors[-3]\nTrue\ncolors[-4]\n9124\ncolors[2]\n'red'\ncolors[3]\n'brown' \n2colors[1:4]\n['green', 'red', 'brown']\ncolors[0:4]\n['blue', 'green', 'red', 'brown']\n\n1\n\nHere, we are using the negative indexing to iterate from the back of the list and colors[-1] will return the last element/item of the list.\n\n2\n\nWe can also use the slicing (a range of values in a list) in a list to specify the range to tell it where to start and where to stop. colors[0:4] Here, you can see we tell Python to start from the index 0 and goes upto 4 (but 4 is not included because indexing starts from 0 that’s why it will stop on 3. if you start from 0 like (0, 1, 2, 3) == 4 elements.)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#nested-list",
    "href": "1. python basics/4-lists.html#nested-list",
    "title": "4  Lists",
    "section": "4.2 Nested List",
    "text": "4.2 Nested List\nLet’s create a Nested list in Python:\ncars = ['toyota', 'mercedes', 'benz', ['tesla x', 'tesla y', 'tesla z']]\nprint(cars[0:2]) # Output: ['toyota', 'mercedes', 'benz']\n1print(cars[3])  # Output: ['tesla x', 'tesla y', 'tesla z']\n2print(cars[3][0]) # Output: 'tesla x'\n3print(cars[3][0:2]) # Output: ['tesla x', 'tesla y']\n\n1\n\ncars[3] will give the value on index 3 which is the nested list inside the cars list.\n\n2\n\nThis cars[3][0] expression tells Python to go on the third item on the list cars then on the third element fetch element on index 0 and return it.\n\n3\n\ncars[3][0:2] expression tells Python to extract elements ranging from 0 up to 2 from the nested list within cars.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#changing-values-of-a-list-by-indexes",
    "href": "1. python basics/4-lists.html#changing-values-of-a-list-by-indexes",
    "title": "4  Lists",
    "section": "4.3 Changing Values of a List by Indexes",
    "text": "4.3 Changing Values of a List by Indexes\nNormally, when we change the value of a variable we use the variable name and the corresponding value, But in the case of lists we use the index to change the value of a particular item. e.g. Let’s look at the following coding example:\ncars = ['toyota', 'mercedes', 'benz', ['tesla x', 'tesla y', 'tesla z']]\n\ncars[0] = 'Toyota Phoenix'\nprint(cars[0]) # value changed from 'toyota' to 'Toyota Phoenix'\n\n# Changing the value using Negative indexing\ncars[-1] = ['A', 'B', 'C', 'D'] # This replaces the list of Tesla car names\nprint(cars[-1])\n\n# Print the whole list\nprint(cars)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#list-concatenation-replication",
    "href": "1. python basics/4-lists.html#list-concatenation-replication",
    "title": "4  Lists",
    "section": "4.4 List Concatenation & Replication",
    "text": "4.4 List Concatenation & Replication\nTo concatenate the list we can use the + operator and to make multiple copies we use the * operator just like the following:\n# The multiplication operator will create 3 copies of the same list and will merge them\nprint([1, 2, 3, 4] * 3)\n\n# Addition operator concatenates or chains together multiple lists into a single list.\n\nprint([1, 2, 3, 4] + [5, 6, 7, 8] + [9, 10, 11, 12, 13])",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#removing-values-from-lists",
    "href": "1. python basics/4-lists.html#removing-values-from-lists",
    "title": "4  Lists",
    "section": "4.5 Removing Values from Lists",
    "text": "4.5 Removing Values from Lists\nThe remove(), pop(), and del are three different methods in Python used for removing elements from a list, but they have distinct functionalities:\n\nremove(value) Method:\n\nUsage: list.remove(value)\nFunctionality: Removes the first occurrence of the specified value from the list.\nExample:\nmy_list = [10, 20, 30, 20, 40]\nmy_list.remove(20)\nprint(my_list)  # Output: [10, 30, 20, 40]\n\npop(index) Method:\n\nUsage: element = list.pop(index)\nFunctionality: Removes and returns the element at the specified index. If no index is provided, it removes and returns the last element.\nExample:\nmy_list = [10, 20, 30, 40]\nremoved_element = my_list.pop(1)\nprint(removed_element)  # Output: 20\nprint(my_list)  # Output: [10, 30, 40]\n\ndel Statement:\n\nUsage: del list[index] or del list[start:end] or del list\nFunctionality: Deletes the specified element(s) or the entire list.\nExamples:\n\nDelete a specific element by index:\nmy_list = [10, 20, 30, 40]\ndel my_list[1]\nprint(my_list)  # Output: [10, 30, 40]\nDelete a slice of the list:\nmy_list = [10, 20, 30, 40]\ndel my_list[1:3]\nprint(my_list)  # Output: [10, 40]\nDelete the entire list:\nmy_list = [10, 20, 30, 40]\ndel my_list\n# Raises an error if you try to access my_list after deletion\n\n\n\nKey Points:\n\nremove() is used when you know the value you want to remove.\npop() is used when you want to remove an element by its index and optionally retrieve its value.\ndel is a more general statement that can delete elements by index or slices, or even delete entire lists.\n\nChoose the method that best fits your specific use case based on whether you need to remove by value, by index, or delete specific elements or slices.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#working-with-lists",
    "href": "1. python basics/4-lists.html#working-with-lists",
    "title": "4  Lists",
    "section": "4.6 Working with Lists",
    "text": "4.6 Working with Lists\nWhen you first begin writing programs it’s tedious to create many variables of the same type. For example to store my car collection:\n\n# Long way to store multiple values in different variable names\nCertainly! Here are nine different car model names:\n\ncar1 = \"Toyota Camry\"\ncar2 = \"Ford Mustang\"\ncar3 = \"Honda Civic\"\ncar4 = \"BMW 3 Series\"\ncar5 = \"Chevrolet Corvette\"\ncar6 = \"Mercedes-Benz E-Class\"\ncar7 = \"Volkswagen Golf\"\ncar8 = \"Tesla Model S\"\ncar9 = \"Nissan Rogue\"\nThis turns out that this is a bad way to write code. (I also don’t own these cars, I swear, I just copied these names from the Internet)\nInstead of using multiple repetitive variables, you can use a single variable that has list of values. For example, here’s a new and improved version of the above source code.\ncars_collection = []\nwhile True:\n    print('Enter the name of Car or Leave it empty to Quit:')\n    name = input()\n    if name == \"\":\n        break\n    else:\n        # list Concatenation \n        cars_collection = cars_collection + [name] \nprint('Collection: ',cars_collection)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#iteration",
    "href": "1. python basics/4-lists.html#iteration",
    "title": "4  Lists",
    "section": "4.7 Iterate through Lists",
    "text": "4.7 Iterate through Lists\nIn the previous lessons we have seen loops execute a block of code a certain number of times. For loop execute the code in the loop body for each item in the range. e.g.\nfor i in range(4):\n    print(i)\n\n\"\"\" Output: 0\n            1\n            2\n            3\n\"\"\"\n# This is because Python looks at this range function as [0, 1, 2, 3] and retrieves an item at a time from the list.\nWe will use the range function to iterate through the following list and will access values by its index:\ncars_collection = [\"Toyota Camry\",\n                    \"Ford Mustang\",\n                    \"Honda Civic\",\n                    \"BMW 3 Series\",\n                    \"Chevrolet Corvette\",\n                    \"Mercedes-Benz E-Class\",\n                    \"Volkswagen Golf\",\n                    \"Tesla Model S\",\n                    \"Nissan Rogue\"]\n# Assign the first value of the list to the 'car_name' variable and print it.\nfor car_name in cars_collection:\n    print(car_name)\n\n# Accessing value by index, range() & len() function\nfor index in range(len(cars_collection)):\n    print(cars_collection[index])",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#in-and-not-in-operators",
    "href": "1. python basics/4-lists.html#in-and-not-in-operators",
    "title": "4  Lists",
    "section": "4.8 in and not in Operators",
    "text": "4.8 in and not in Operators\nWe can determine whether a value is present in a list or not by using in & not in operators. e.g. Enter the following into the interactive shell:\n# Output: True\n'salih' in ['sadiq','safi','salih','qaisar','ikram']\n\nanimals = ['cat', 'dog', 'bird', 'cow']\n'cat' in animals # Output: True\n'elephant' in animals # Output: False",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#multiple-assignment-using-lists",
    "href": "1. python basics/4-lists.html#multiple-assignment-using-lists",
    "title": "4  Lists",
    "section": "4.9 Multiple Assignment using Lists",
    "text": "4.9 Multiple Assignment using Lists\nToyota = ['20 miles', '2016', '2024', 'Red']\nmileage, model, year, color = toyota[0], toyota[1], toyota[2], toyota[3]\n\nprint(mileage)\nprint(model)\nprint(year)\nprint(color)\nYou can also assign values to variables like below:\nToyota = ['20 miles', '2016', '2024', 'Red']\nmileage, model, year, color = Toyota\nprint(mileage)\nprint(model)\nprint(year)\nprint(color)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#using-enumerate-function-with-lists",
    "href": "1. python basics/4-lists.html#using-enumerate-function-with-lists",
    "title": "4  Lists",
    "section": "4.10 Using enumerate() function with Lists",
    "text": "4.10 Using enumerate() function with Lists\nThe enumerate() function is useful if you want both index & value. Instead of using range(len(list name)) let’s do the same with enumerate().\ncars_collection = [\"Toyota Camry\",\n                    \"Ford Mustang\",\n                    \"Honda Civic\",\n                    \"BMW 3 Series\",\n                    \"Chevrolet Corvette\",\n                    \"Mercedes-Benz E-Class\",\n                    \"Volkswagen Golf\",\n                    \"Tesla Model S\",\n                    \"Nissan Rogue\"]\n\nfor index, value in enumerate(cars_collection):\n    print(f'Index is: {index}\\nValue is: {value}')\n    \nStarting Index from a Specific Value:\nmy_list = ['apple', 'banana', 'orange']\nfor index, value in enumerate(my_list, start=1):\n    print(f\"Index: {index}, Value: {value}\")\nUsing Random module with Lists\nThe random module in Python can be used to perform various operations with lists. Here are a few examples:\n\nShuffling a List:\nimport random\n\nmy_list = [1, 2, 3, 4, 5]\nrandom.shuffle(my_list)\nprint(\"Shuffled List:\", my_list)\nSelecting a Random Element from a List:\nimport random\n\nfruits = ['apple', 'banana', 'orange', 'grape', 'kiwi']\nrandom_fruit = random.choice(fruits)\nprint(\"Random Fruit:\", random_fruit)\nRandom Sampling from a List:\nimport random\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nrandom_sample = random.sample(numbers, k=3)\nprint(\"Random Sample:\", random_sample)\nGenerating Random Numbers within a Range:\nimport random\n\nrandom_number = random.randint(1, 100)\nprint(\"Random Number between 1 and 100:\", random_number)\nRandomizing List Order for a Specific Task:\nimport random\n\ntasks = ['Task A', 'Task B', 'Task C', 'Task D']\nrandom.shuffle(tasks)\nprint(\"Randomized Order for Task Execution:\", tasks)\n\nThese are just a few examples, and the random module provides more functions for working with randomness in Python. Depending on your specific use case, you can choose the appropriate function from the random module to achieve the desired behavior with lists.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#in-place-operators-or-compound-assignment-operators",
    "href": "1. python basics/4-lists.html#in-place-operators-or-compound-assignment-operators",
    "title": "4  Lists",
    "section": "4.11 In-Place Operators or Compound Assignment Operators:",
    "text": "4.11 In-Place Operators or Compound Assignment Operators:\nIn Python, augmented assignment operators are shorthand syntax for performing an operation and assigning the result to the same variable. They combine an operation (like addition or multiplication) with the assignment. Here are some examples:\n\nAddition: +=\nx = 5\nx += 3  # Equivalent to x = x + 3\nprint(x)  # Output: 8\nSubtraction: -=\ny = 10\ny -= 4  # Equivalent to y = y - 4\nprint(y)  # Output: 6\nMultiplication: *=\nz = 3\nz *= 2  # Equivalent to z = z * 2\nprint(z)  # Output: 6\nDivision: /=\na = 15\na /= 3  # Equivalent to a = a / 3\nprint(a)  # Output: 5.0\nModulus: %=\nb = 17\nb %= 5  # Equivalent to b = b % 5\nprint(b)  # Output: 2\nExponentiation: **=\nc = 2\nc **= 3  # Equivalent to c = c ** 3\nprint(c)  # Output: 8\nFloor Division: //=\nd = 25\nd //= 4  # Equivalent to d = d // 4\nprint(d)  # Output: 6\n\nThese operators are concise ways to update the value of a variable based on its current value and the result of an operation. They can be useful for making code more readable and efficient.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#insert-append-methods-of-list",
    "href": "1. python basics/4-lists.html#insert-append-methods-of-list",
    "title": "4  Lists",
    "section": "4.12 insert() & append() methods of List",
    "text": "4.12 insert() & append() methods of List\nLet’s keep it simple:\n\nappend() method:\n\nWhat it does: Adds something to the end of a list.\nExample: If you have a list of fruits and you want to add a new fruit to the end, you use append().\n\ninsert() method:\n\nWhat it does: Adds something to a specific position in a list.\nExample: If you have a list of friends and you want to add a new friend at a particular spot, you use insert().\n\n\nSo, append() adds to the end, and insert() adds at a specific place. Easy, right?\n# Using append() to add to the end of a list\nfruits = ['apple', 'banana', 'orange']\nfruits.append('grape')\n# Now, fruits is ['apple', 'banana', 'orange', 'grape']\n\n# Using insert() to add at a specific position in a list\nfriends = ['Alice', 'Bob', 'Charlie']\nfriends.insert(1, 'David')\n# Now, friends is ['Alice', 'David', 'Bob', 'Charlie']",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#sorting-value-of-list-using-sort-method",
    "href": "1. python basics/4-lists.html#sorting-value-of-list-using-sort-method",
    "title": "4  Lists",
    "section": "4.13 Sorting value of list using sort() Method:",
    "text": "4.13 Sorting value of list using sort() Method:\nValues inside the list can be sorted with sort() method:\nnumber = [1,5,3,2,7,4,3]\n\n# Sort it in ascending order\nnumber.sort()\nprint('Descending order: ',number)\n\n# Sort it in descending order by passing `reverse` parameter\nnumber.sort(reverse=True)\nprint('Ascending order: ',number)\n\n# You can also sort list contain strings in alphabetical order\n# You cannot sort list contain both string & number\n\n# sort() uses 'ASCIIbetical order' rather than actual alphabetical order for sorting strings which means uppercase letters comes before lowercase letters.\nmy_list = ['apple','Apple', 'banana', 'Banana', 'orange', \n'grape', 'kiwi', 'melon', 'peach', 'pear', 'strawberry', 'blueberry']\nmy_list.sort()\nprint(my_list)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#reversing-the-values-of-list",
    "href": "1. python basics/4-lists.html#reversing-the-values-of-list",
    "title": "4  Lists",
    "section": "4.14 Reversing the Values of List",
    "text": "4.14 Reversing the Values of List\nTo reverse the order of a list you can call reverse() method on the list. e.g.\ncount = [1, 2, 3, 4, 5, 6]\ncount.reverse()\nprint(count)\n\n\n\n\n\n\nLine Continuation Character\n\n\n\nSome time we want to organize our long line of code and to make it look pretty and readable. So, we use  line continuation character at the end. This tells python that line is continues and it don’t end here. For example, look at the following code:\nlong_text = \"This is a very long text that \\\ncontinues on the next line using the continuation character.\"\n\nprint(long_text)\n\n# Continuation on lists\ncolors = ['red', 'green', 'blue', \\\n          'yellow', 'orange', 'purple']\n\nprint(colors)\n\n# Continuation on numbers\nequation = 3 +  \\\n           5 *  \\\n           2\n\nprint(equation)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#string-lists-similarities",
    "href": "1. python basics/4-lists.html#string-lists-similarities",
    "title": "4  Lists",
    "section": "4.15 String & Lists Similarities",
    "text": "4.15 String & Lists Similarities\nIn Python, strings and lists share some similarities:\n\nOrdered Sequence:\n\nBoth strings and lists are ordered sequences, meaning the order in which elements appear is maintained.\n\nIndexing:\n\nYou can access individual elements in both strings and lists using indexing. For example, my_string[0] or my_list[0] refers to the first element.\n\nSlicing:\n\nBoth support slicing to extract a portion of the sequence. For instance, my_string[1:4] or my_list[1:4] extracts elements from index 1 to 3.\n\nIterability:\n\nBoth can be iterated using loops. You can use a for loop to go through each character in a string or each element in a list.\n\nConcatenation:\n\nYou can concatenate strings using the + operator, and you can concatenate lists using the + operator as well.\n\nInclusion:\n\nBoth can use the in operator to check if a specific element is present in the sequence.\n\n\nHere’s a quick example showcasing these similarities:\n# Strings\nmy_string = \"Hello, World!\"\nprint(my_string[0])        # Output: H\nprint(my_string[7:12])     # Output: World\nprint('W' in my_string)    # Output: True\n\n# Lists\nmy_list = [1, 2, 3, 4, 5]\nprint(my_list[2])          # Output: 3\nprint(my_list[1:4])        # Output: [2, 3, 4]\nprint(3 in my_list)        # Output: True\nDespite these similarities, it’s crucial to note that strings are immutable (you can’t change individual characters once the string is created), while lists are mutable (you can modify, add, or remove elements).",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#lists",
    "href": "1. python basics/4-lists.html#lists",
    "title": "4  Lists",
    "section": "4.16 Tuple cousin of Lists",
    "text": "4.16 Tuple cousin of Lists\nTuples are identical to lists except it create with parenthesis () rather than curly braces [] like lists. Another distinction between list & tuple is that tuple is immutable (can’t change its values) like strings. If you want to create a tuple with a single value then type a single comma after the value. This comma is what lets Python know this is a tuple value. If you don’t place trailing comma after the value Python will think of it as a regular string:\nType the following into editor & see its types:\nnot_tup = ('hours')\nprint(type(tup))\n\ntup = ('hours',)\nprint(type(tup))\n\nmy_list = ['hours']\nprint(type(my_list))\nNow, let’s create some tuples and try to tweak it a little bit and apply some of the list operations on it:\nmy_tuple = ('apple', 5, 3.14, 'banana', 7, 2.718)\n\n# looping through tuple using slicing\nprint(my_tuple[1:3])\n\n# Accessing value the way we access of list\n1print(my_tuple[0])\n\n# Changing the value of tuple (Remember tuple are Immutable)\n2my_tuple[0] = 'Apple'\n\n1\n\nWe can access tuple value like the way we access of lists.\n\n2\n\nThis will cause error TypeError: 'tuple' object does not support item assignment because tuple values can’t be changed",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#converting-types-with-list-tuple-functions",
    "href": "1. python basics/4-lists.html#converting-types-with-list-tuple-functions",
    "title": "4  Lists",
    "section": "4.17 Converting Types with list() & tuple() functions",
    "text": "4.17 Converting Types with list() & tuple() functions\nThe list() and tuple() functions in Python are used for converting between different sequence types. Here are some common use cases for these functions:\n\n4.17.1 list() functions:\n\nConvert String to List of Words:\nmy_string = \"Hello, how are you?\"\nword_list = list(my_string.split())\nprint(word_list)\nConvert Range to List:\nnumber_range = range(1, 6)\nnumber_list = list(number_range)\nprint(number_list)\nClone Another List:\noriginal_list = [1, 2, 3, 4, 5]\nnew_list = list(original_list)\nConvert Tuple to List:\n# Converting tuple to list\nmy_tuple = (10, 20, 30, 40, 50)\nmy_list = list(my_tuple)\nprint(my_list)\n\n\n\n4.17.2 tuple() functions:\n\nConvert List to Tuple:\nmy_list = [10, 20, 30, 40, 50]\nmy_tuple = tuple(my_list)\nprint(my_tuple)\nConvert String to Tuple of Characters:\nmy_string = \"Python\"\nchar_tuple = tuple(my_string)\nprint(char_tuple)\nCreate a Tuple from Values:\nvalues_tuple = tuple(1, 2, 3, 4, 5)\nprint(values_tuple)\nThese functions are versatile and can be used in various scenarios where you need to convert one sequence type to another.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#reference-to-variables",
    "href": "1. python basics/4-lists.html#reference-to-variables",
    "title": "4  Lists",
    "section": "4.18 Reference to Variables",
    "text": "4.18 Reference to Variables\nVariables in Python act as references to objects (values) in memory. For example, when you do x = 10, x is a reference to the memory location where the value 10 is stored. Let’s look at the following code block:\n# Creating references\na = 5  # 'a' is a reference to the value 5\nb = [1, 2, 3]  # 'b' is a reference to a list [1, 2, 3]\n\n# Modifying through references\na = a + 1  # Creates a new object (6) and updates 'a' to reference it\nb.append(4)  # Modifies the list object directly\n\n# Passing references to a function\ndef modify_list(lst):\n    lst.append(5)\n\nmodify_list(b)  # 'b' is passed by reference, and the list is modified\n\n# Changing reference\nc = b  # 'c' now references the same list as 'b'\nIn simple words, reference means when you create variable var1 = data variable (var1) point to the address of value data on computer memory. For example in the following code you can find the address of a variable using id() function.\n\n# Creating different names variable with same value\n1var1 = 'data'\nvar2 = 'data'\nvar3 = 'data'\n\n# Find memory address using id() method\nprint(id(var1))\nprint(id(var2))\nprint(id(var3))\n\n# Create variable with different value \n2var4 = 'data1'\nvar5 = 'data2'\n\nprint(id(var4))\nprint(id(var5))\n\n1\n\nAs you can see these three variable have same value so their value won’t create separate memory address rather all of them will point to the same memory address.\n\n2\n\nvar4 & var5 have different values so each variable will create their own memory address.\n\n\n\n\n\nVariable Reference\n\n\ncomputers = [1, 2, 3, 4, 5, 6]\nlaptop = computers\nmobile = computers\n\n\n# Below all will return the same memory address because all of the variable have same value. So, all of them would point to the memory address of [1, 2, 3, 4, 5, 6] instead of creating identical copy of it.\n\nprint(f'Address 1: {id(computers)}\\nAddress 2: {id(laptop)}\\nAddress 3: {id(mobile)}')\nDifferent Variable of Same Value You can create two lists with the same values using different variables. Here’s an example:\n# Creating two lists with the same values\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [1, 2, 3, 4, 5]\n\n# Checking if they have the same values\nprint(\"Are the lists equal?\", list1 == list2)\n\n# Checking if they are different objects (different variables)\nprint(\"Are the variables different?\", list1 is not list2)\n\n# Checking memory address of both\nprint(id(list1),id(list2))\nprint(id(list1) == id(list2))\nIn this example, list1 and list2 have the same values, but they are different objects with different memory addresses. The == operator checks for equality of values, and the is operator checks if they refer to the same object in memory.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#copy-and-deepcopy-functions",
    "href": "1. python basics/4-lists.html#copy-and-deepcopy-functions",
    "title": "4  Lists",
    "section": "4.19 copy() and deepcopy() functions",
    "text": "4.19 copy() and deepcopy() functions\nThe copy() and deepcopy() functions are used to create copies of objects in Python, but they behave differently when dealing with nested or complex objects like lists within lists or dictionaries within dictionaries.\nHere’s an example using both functions:\nimport copy\n\n# Original list with nested lists\noriginal_list = [1, [2, 3, 4], 5]\n\n# Using copy() to create a shallow copy\nshallow_copy = copy.copy(original_list)\n\n# Using deepcopy() to create a deep copy\ndeep_copy = copy.deepcopy(original_list)\n\n# Modifying the original list\noriginal_list[1][0] = 'X'\n\n# Displaying the original and copied lists\nprint(\"Original List:\", original_list)\nprint(\"Shallow Copy:\", shallow_copy)\nprint(\"Deep Copy:\", deep_copy)\n\n# Output :\n      # Original List: [1, ['X', 3, 4], 5]\n      # Shallow Copy: [1, ['X', 3, 4], 5]\n      # Deep Copy: [1, [2, 3, 4], 5]\nIn this example, copy.copy() creates a shallow copy, and copy.deepcopy() creates a deep copy. The difference becomes apparent when the original list is modified. The shallow copy retains references to the nested lists, so changes inside the nested lists are reflected in both the original and shallow copy. The deep copy, on the other hand, creates entirely new objects for the nested lists, making it independent of changes in the original.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "1. python basics/4-lists.html#practice-questions",
    "href": "1. python basics/4-lists.html#practice-questions",
    "title": "4  Lists",
    "section": "4.20 Practice Questions",
    "text": "4.20 Practice Questions\n\n\n\n\n\nHow would you assign the value ‘world’ as the third element in a list stored in a variable named eggs? (Assume eggs contains [1, 3, 5, 7, 9]).\n\n eggs = [1, 3, 5, 7, 9]  eggs.insert(2, ‘world’) print(eggs) \n\n\n\nmy_list = [10, 20, 30, 40, 50] How would you remove the element 30 from the list without using the remove() method?\n\n my_list = [10, 20, 30, 40, 50] new_list = [i for i in my_list if i != 30] print(new_list) \n\n\n\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]How can you remove all occurrences of the number 5 from the list without using the remove() method?\n\n numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] new_numbers = [num for num in numbers if num != 5] print(new_numbers)\n\n\n\n\n\n\n\nSource: https://www.dataquest.io\nVariable Reference",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "ChatGPT Guide/prompt engineering basics.html",
    "href": "ChatGPT Guide/prompt engineering basics.html",
    "title": "10  Intro to ChatGPT",
    "section": "",
    "text": "10.1 Basic Initiating Phrases\nYou can start with the Initial starter prompts to get your desired results.",
    "crumbs": [
      "Mastering Prompt Engineering (ChatGPT)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Intro to ChatGPT</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html",
    "href": "1. python basics/5-dictionaries.html",
    "title": "5  Dictionaries",
    "section": "",
    "text": "5.1 Dictionary vs Lists\nLists are ordered, while dictionaries are unordered. For Example, look at the following code to differentiate both:",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#nested-dictionaries",
    "href": "1. python basics/5-dictionaries.html#nested-dictionaries",
    "title": "5  Dictionaries",
    "section": "5.6 Nested Dictionaries:",
    "text": "5.6 Nested Dictionaries:\n# Example of a nested dictionary representing information about a person\nperson_info = {\n    'name': 'Asad',\n    'age': 22,\n    'address': {\n        'city': 'Peshawar',\n        'country': 'Pakistan',\n        'zipcode': '12345'\n    },\n    'contacts': {\n        'email': 'asad@example.com',\n        'phone': '123-456-7890'\n    }\n}\n\n# Accessing nested values\nprint(person_info['address']['city'])  # Output: 'Peshawar'\nprint(person_info['contacts']['email'])  # Output: 'asad@example.com'\nIn this example, the person_info dictionary contains nested dictionaries for ‘address’ and ‘contacts’, creating a hierarchical structure.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#nested-lists",
    "href": "1. python basics/5-dictionaries.html#nested-lists",
    "title": "5  Dictionaries",
    "section": "5.7 Nested Lists:",
    "text": "5.7 Nested Lists:\n# Example of a nested list representing a matrix\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Accessing elements in the nested list\nprint(matrix[1][2])  # Output: 6 (row 1, column 2)\nHere, the matrix list is nested, forming a 2D list. Elements can be accessed using indices for both the outer list (row) and the inner list (column).\nYou can also have a combination of nested dictionaries and lists:\n# Example of a nested dictionary containing a nested list\norganization = {\n    'name': 'TechCorp',\n    'departments': {\n        'engineering': ['Software', 'Hardware'],\n        'sales': ['Domestic', 'International'],\n        'hr': ['Recruitment', 'Employee Relations']\n    }\n}\n\n# Accessing elements in the nested structure\nprint(organization['departments']['engineering'][0])  # Output: 'Software'\nIn this example, the departments key in the organization dictionary contains a nested dictionary with department names as keys and lists of sub-departments as values.\nThese examples illustrate how nesting dictionaries and lists allows you to represent more intricate and organized data structures in your Python programs.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#dictionary-vs-lists",
    "href": "1. python basics/5-dictionaries.html#dictionary-vs-lists",
    "title": "5  Dictionaries",
    "section": "",
    "text": "# List\nmy_list = [10, 20, 30, 40, 50]\n# Shuffling above list\nshuffled_list = [30, 20, 40, 10, 50]\n\nprint(my_list == shuffled_list)\n\n# Dictionary\nmy_dict = {\n    'apple': 5,\n    'banana': 8,\n    'orange': 12,\n    'grape': 20,\n    'kiwi': 3\n}\n\n# Shuffled version of the above dictionary\nshuffled_my_dict = {\n    'banana': 8,\n    'orange': 12,\n    'apple': 5,\n    'kiwi': 3,\n    'grape': 20\n}\n\nprint(my_dict == shuffled_my_dict)\n\n\n\n\n\n\nNote\n\n\n\nAs you can see, if you keep the content of a list the same and just change its order, Python won’t accept it as equal. As for the dictionaries you can see no matter what the order of the key-value pair is, python would still consider it as a copy of the first dictionary because in a dictionary we access values by its key, unlike indexes which must be to access it in order.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#the-keys-values-items-get-methods",
    "href": "1. python basics/5-dictionaries.html#the-keys-values-items-get-methods",
    "title": "5  Dictionaries",
    "section": "5.2 The keys(), values(), items() & get() methods",
    "text": "5.2 The keys(), values(), items() & get() methods\n\nThe keys() method returns the keys of a dictionary in a list-like format but not exactly a list. For Example:\n    my_dict = {\n    'apple': 5,\n    'banana': 8,\n    'orange': 12,\n    'grape': 20,\n    'kiwi': 3\n}\n\nfor key in my_dict.keys():\n    print(key)\nThe values() method returns values of the dictionary in list-like format. For Example:\n    my_dict = {\n    'apple': 5,\n    'banana': 8,\n    'orange': 12,\n    'grape': 20,\n    'kiwi': 3\n}\n\nfor value in my_dict.values():\n    print(value)\nThe items() method returns both keys and values separately. For Example: ```python my_dict = { ‘apple’: 5, ‘banana’: 8, ‘orange’: 12, ‘grape’: 20, ‘kiwi’: 3 }\n for key, value in my_dict.items():\n     print(key,' : ', value)\n\n print(type(my_dict.values()))\nget() Sometimes we want to return the value of a key in a dictionary but what if the key doesn’t exist then it would give you a tedious and ugly error message. Fortunately, to prevent such error messages python has the get() method on dictionary that returns None by default else returns the user-defined value. For Example:\n my_dict = {\n     'name': 'Asad',\n     'age': 22,\n     'city': 'Peshawar',\n     'occupation': 'Student',\n     'interest': 'Machine Learning'\n }\n\n # Using get() to retrieve values\n name_value = my_dict.get('name')\n\n # If gender key isn't in `my_dict` dictionary then it would return `Not specified`\n gender_value = my_dict.get('gender', 'Not specified')\n\n print(name_value)      # Output: 'Asad'\n print(gender_value)    # Output: 'Not specified' (since the 'gender' key is not present)\nIf you run print(type(my_dict.values())) this will return a view of the values in a dictionary which if I explain simply to an 8 grader child then ‘view of the values’ would be like a mirror which facing the current dictionary within which we can see all the values inside of that dictionary but if we change the values inside dictionary this affect the view of the values also.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#value-or-key-exists",
    "href": "1. python basics/5-dictionaries.html#value-or-key-exists",
    "title": "5  Dictionaries",
    "section": "5.3 Value or Key exists",
    "text": "5.3 Value or Key exists\nIf you remember from the last chapter we saw in and not in operators from the past chapters. We can also use this operator on dictionaries to see if a certain key or value exists in a dictionary or not.\n    my_dict = {\n        'name': 'Asad',\n        'age': 22,\n        'city': 'Peshawar',\n        'occupation': 'Student',\n        'interest': 'Machine Learning'\n    }\n\n    result_1, result_2 = 'name' in my_dict.keys(), 'Student' not in my_dict.values()\n\n    print('Name key exists in my_dict: ',result_1)\n    print('Student value not exist in my_dict: ',result_2)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#pprint-module",
    "href": "1. python basics/5-dictionaries.html#pprint-module",
    "title": "5  Dictionaries",
    "section": "5.4 pprint Module",
    "text": "5.4 pprint Module\n1import pprint\n\nmy_dict = {\n    'name': 'Asad',\n    'age': 22,\n    'city': 'Peshawar',\n    'occupation': 'Student',\n    'interest': 'Machine Learning'\n}\n\n# Set the key `cast` if it's not in my_dict\nmy_dict.setdefault('cast',' Khalil Mohmand')\n\n# key & value would remain the same as above because we have the key of `cast` already\nmy_dict.setdefault('cast', 'Yousaf Zai')\npprint.pprint(my_dict)\n\n1\n\nThe pprint module stands for ‘pretty-print’. It provides a way to print data structures like dictionaries, and lists in a more human-readable and aesthetically pleasing format especially when dealing with nested or complex structures. The pprint module is part of the Python standard library.\n\n\n\n\n\n\n\n\nPython Standard Library vs Third Party Library\n\n\n\nPython Standard Library means modules that come with Python installation and don’t require any additional installation while Third Party Library are the modules that you have to install manually when you need it e.g. If we need a numpy module we have to first install it using package manager pip i.e. pip install numpy.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#pprintvs-pformat-methods",
    "href": "1. python basics/5-dictionaries.html#pprintvs-pformat-methods",
    "title": "5  Dictionaries",
    "section": "5.5 pprintvs pformat methods",
    "text": "5.5 pprintvs pformat methods\nBoth are these method works the same unless you want the output to save somewhere. In simple, if you want to store the formatted output into a file then use pformat else use the pprint method. For Example:\nfrom pprint import pformat, pprint\n\n# Example dictionary with nested structure\ncomplex_dict = {\n    'name': 'Asad',\n    'age': 22,\n    'details': {\n        'city': 'Peshawar',\n        'interests': ['Machine Learning', 'Gardening']\n    }\n}\n\n# Below will return its output and can be saved to a text file.\nwith open('pformat.txt','w') as writer:\n    writer.write(pformat(complex_dict))\n\n# You can see the result of pprint on the console but you can't store it in a text file that's you will get an error by running the below code:\nwith open('pprint.txt','w') as writer:\n    writer.write(pprint(complex_dict)) \n\n\n\n\n\n\nTip\n\n\n\nThe pprint.pprint() function is useful especially when you have a nested dictionary or dictionary with a complex structure.\n\n\nNested dictionaries and lists in Python allow you to create more complex data structures by placing dictionaries or lists inside other dictionaries or lists. This is particularly useful when dealing with hierarchical or structured data. Here are examples of both nested dictionaries and nested lists:",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html",
    "href": "1. python basics/6-string manipulation.html",
    "title": "6  String Manipulations",
    "section": "",
    "text": "6.1 Double vs Single & Escape Characters Quotes\nStrings can begin & end with single or double quotes. But when we need to use a quote (either single or double) inside a string then there we need Escape Characters which is the way to tell the program to treat this character as a string not as a keyword e.g. look at the following example:\nBelow are some Escape Characters that we can use:",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/5-dictionaries.html#pprint-vs-pformat-methods",
    "href": "1. python basics/5-dictionaries.html#pprint-vs-pformat-methods",
    "title": "5  Dictionaries",
    "section": "5.5 pprint vs pformat methods",
    "text": "5.5 pprint vs pformat methods\nBoth are these method works the same unless you want the output to save somewhere. In simple, if you want to store the formatted output into a file then use pformat else use the pprint method. For Example:\nfrom pprint import pformat, pprint\n\n# Example dictionary with nested structure\ncomplex_dict = {\n    'name': 'Asad',\n    'age': 22,\n    'details': {\n        'city': 'Peshawar',\n        'interests': ['Machine Learning', 'Gardening']\n    }\n}\n\n# Below will return its output and can be saved to a text file.\nwith open('pformat.txt','w') as writer:\n    writer.write(pformat(complex_dict))\n\n# You can see the result of pprint on the console but you can't store it in a text file that's you will get an error by running the below code:\nwith open('pprint.txt','w') as writer:\n    writer.write(pprint(complex_dict)) \n\n\n\n\n\n\nTip\n\n\n\nThe pprint.pprint() function is useful especially when you have a nested dictionary or dictionary with a complex structure.\n\n\nNested dictionaries and lists in Python allow you to create more complex data structures by placing dictionaries or lists inside other dictionaries or lists. This is particularly useful when dealing with hierarchical or structured data. Here are examples of both nested dictionaries and nested lists:",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#double-vs-single-escape-characters-quotes",
    "href": "1. python basics/6-string manipulation.html#double-vs-single-escape-characters-quotes",
    "title": "6  String Manipulations",
    "section": "",
    "text": "1q = \"Who're you\" # Correct Structure\n\nq = 'who're you' # Faulty code\n\nq = 'who\\'re you' # Using Escape Sequence \n\na = \"I\\\"m khan\" # Using Escape Sequence \n\n1\n\nHere, if you start your string with a single quote and then somewhere between you need a single quote as a string literal not the ending quote then we need to tell the Python program to treat it as a string by Escape Sequence ().\n\n\n\n\nList of Escape characters you can use.\n\n\nEscape character\nOutput\n\n\n\n\n\\\nBackslash\n\n\n\\t\nTab\n\n\n\\n\nnewline\n\n\n'\nsingle quote\n\n\n\"\ndouble quote",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#raw-string",
    "href": "1. python basics/6-string manipulation.html#raw-string",
    "title": "6  String Manipulations",
    "section": "6.2 Raw String",
    "text": "6.2 Raw String",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#raw-strings",
    "href": "1. python basics/6-string manipulation.html#raw-strings",
    "title": "6  String Manipulations",
    "section": "6.2 Raw Strings",
    "text": "6.2 Raw Strings\nPlacing r at the beginning quotation mark of a string will make it a raw string. A raw string completely ignores all the special characters used inside the string and will print it as it is.\n1print(r'C:\\Users\\User\\Desktop\\platform-tools'Hello'\\iam')\n# Output: C:\\Users\\User\\Desktop\\platform-tools'Hello'\\iam\n\n1\n\nRaw strings are useful when we have a lot of special characters in our strings.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#multiline-strings",
    "href": "1. python basics/6-string manipulation.html#multiline-strings",
    "title": "6  String Manipulations",
    "section": "6.3 Multiline Strings",
    "text": "6.3 Multiline Strings\nWe can use ‘\\n’ to tell Python Interpreter to start from the new line but a good practice is to use Multiline for such strings that are longer than two lines. E.g.\nprint(\"\"\"Dear Whatsapp,\n            'am being a victim of receiving multiple death \n            threats from an Unknown caller, who wants me to \n            pay them ransom. It's been a half week, since \n            then he tries to breach my social accounts in \n            order to take control of all of my data.\n            \n        I will be sincerely thankful If you could do something about it.\n        Cell No: +92***234***3 \n        Note: I do not receive such threats. Chill!!!\"\"\")\n     \nEscaping single & double quotes are optional in multiline strings as you can see in the single quote at the beginning of the above multiline strings.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#multiline-for-comments-docstrings",
    "href": "1. python basics/6-string manipulation.html#multiline-for-comments-docstrings",
    "title": "6  String Manipulations",
    "section": "6.4 Multiline for Comments & docstrings",
    "text": "6.4 Multiline for Comments & docstrings\nFor a single line of comment, we use (#) hash character but for multiple lines, we use triple quote also. If you write a built-in function in the editor you will see a description like text in the suggestion box about what this function does, that is what docstring is. We can also use triple quotes to give a user-defined function its docstring. E.g.\n\"\"\"\nThis is an example of Multiline comment which is used \\noutside the function to tell what we are going to do with \\nthe following user-defined function.\n\n\"\"\"\n\ndef addition(num1, num2):\n    \"This function does all the addition-related tasks\n        \"\"\"\n    return num1 + num2\n\nprint(addition(23, 22))",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#indexing-and-slicing-strings",
    "href": "1. python basics/6-string manipulation.html#indexing-and-slicing-strings",
    "title": "6  String Manipulations",
    "section": "6.5 Indexing and Slicing Strings",
    "text": "6.5 Indexing and Slicing Strings\nStrings can be accessed via indexing and slicing just like we do with lists but you cannot modify the strings just like we do with lists because strings are immutable, unlike lists.\nwater = 'Un vaso de agua. por favor!'\n\nwater[0] # Accessing the first letter 'U'\nwater[4] # Accessing the fourth letter 'v'\n\nwater[4:] # Start from character 4 up to end\n\nwater [:4] # Start from the beginning up to 4 letter",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#in-not-in-operators-with-strings",
    "href": "1. python basics/6-string manipulation.html#in-not-in-operators-with-strings",
    "title": "6  String Manipulations",
    "section": "6.6 In & not in Operators with Strings",
    "text": "6.6 In & not in Operators with Strings\nThe in and not in operators can be used with strings just like we used before with lists. Run the following in the editor:\nsentence = 'hola! buoneus dias'\n\nprint('hola' in sentence)\nprint('!' in a sentence)\nprint('#' in sentence)\nprint('Dias' not in sentence)\nprint('dias' not in sentence)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#strings-methods",
    "href": "1. python basics/6-string manipulation.html#strings-methods",
    "title": "6  String Manipulations",
    "section": "6.7 Strings Methods",
    "text": "6.7 Strings Methods\nSome of the string methods are mentioned below. Look for others as well on the internet and play with it what more can you do with strings?\nsentence = 'Hola! buoneus dias'\n\n# Convert string to uppercase\nprint(sentence.upper())\n\n# Convert string to lowercase\nprint(sentence.lower())\n\n# Make the first character upper and remain smaller\nprint(sentence.capitalize())\n\n# Convert string to list\nprint(sentence.split())\n\n# Convert uppercase letter to lower & lower to uppercase\nprint(sentence.swapcase())\n\n1print(sentence.isalpha())\nprint(sentence.isupper())\nprint(sentence.islower())\nprint(sentence.isdigit())\n\n1\n\nseveral other string methods start with is, these return boolean results.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#the-join-and-split-methods",
    "href": "1. python basics/6-string manipulation.html#the-join-and-split-methods",
    "title": "6  String Manipulations",
    "section": "6.8 The join() and split() Methods",
    "text": "6.8 The join() and split() Methods",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#the-join-split-partition-methods",
    "href": "1. python basics/6-string manipulation.html#the-join-split-partition-methods",
    "title": "6  String Manipulations",
    "section": "6.8 The join(), split() & partition() Methods",
    "text": "6.8 The join(), split() & partition() Methods\njoin() method\nThe join() method is useful when you have a list of strings that you want to join together in one single string. E.g.\n1sentence = 'Hola! buoneus dias'\nprint(' '.join(sentence))\n\n1\n\nThe abovementioned code will pick a single character from sentence and join a single white space to it.\n\n\nsplit() method\nThe split() method is commonly used to convert a string to a list or to split a multiline string along the newline characters. Enter the following into the editor:\nfrom pprint import pprint\n\nsentence = 'Mi Autobus esta aqui!' \npprint(sentence.split()) \n\nparagraph = \"\"\"\nSemiconductor technology is usually called solid state. This means that the\nmaterials used are of one piece. This is in contrast with the vacuum tube, which\nconsists of a series of assembled parts. Of course, the substances from which \nsemiconductors are made are not solid. They have atomic structures consisting largely of space.\nThe spaces are essential for the movement of electrons.\n\"\"\"\n\npprint(paragraph.split(sep='\\n'))\npartition() method\nThe partition() method splits the string before and after the separator and returns a tuple object, not the list. See the code:\nfrom pprint import pprint\n\n1intro = 'Hello my name is Imran Khan'\npprint(intro.partition('is'))\n\n1\n\nThis would split the string into partitions.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#the-rjust-ljust-center-methods",
    "href": "1. python basics/6-string manipulation.html#the-rjust-ljust-center-methods",
    "title": "6  String Manipulations",
    "section": "6.9 The rjust(), ljust() & center() methods",
    "text": "6.9 The rjust(), ljust() & center() methods\nThe rjust, ljust() & center() methods are simply putting padding to the strings. These methods justify the string by padding it with the specified character (in this case, ‘’) until the total length reaches the specified width (30 in our case). If the string is already longer than the specified width, it won’t truncate it. The original string “abcdefghijklmnopqrstuvwxyz” is 26 characters long, so it adds 4 ’’ characters to the string to make it a total of 30 characters.\nletters = 'abcdefghijklmnopqrstuvwxyz'\n\n# Number of characters in the above variable.\nprint(len(letters))\n\n# rightly-justifies\nprint(letters.rjust(30, '*')) \n\n# left-justifies\nprint(letters.ljust(30, '*')) \n\n# center-justifies\nprint(letters.center(30, '*'))",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#ord-and-chr-functions",
    "href": "1. python basics/6-string manipulation.html#ord-and-chr-functions",
    "title": "6  String Manipulations",
    "section": "6.10 ord() and chr() functions",
    "text": "6.10 ord() and chr() functions\nIn Python, the ord() and chr() functions are used for converting between characters and their corresponding ASCII or Unicode representations.\n\nord(): This function takes a character (a string of length 1) as an argument and returns the ASCII or Unicode code point of that character.\nchr(): This function takes an integer representing an ASCII or Unicode code point and returns the corresponding character.\n\nHere’s a simple example to illustrate their usage:\n# Using ord() to get the ASCII code of a character\nchar = 'A'\nascii_code = ord(char)\nprint(f\"The ASCII code of '{char}' is {ascii_code}\")\n\n# Using chr() to get the character from an ASCII code\ncode_point = 65  # ASCII code for 'A'\ncharacter = chr(code_point)\nprint(f\"The character with ASCII code {code_point} is '{character}'\")\nIn this example: - ord('A') returns 65, which is the ASCII code for the character ‘A’. - chr(65) returns ‘A’, which is the character corresponding to the ASCII code 65.\nThese functions are particularly useful when working with text, and you need to convert characters to their numeric representations or vice versa.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#copying-and-pasting-text-via-pyperclip-module",
    "href": "1. python basics/6-string manipulation.html#copying-and-pasting-text-via-pyperclip-module",
    "title": "6  String Manipulations",
    "section": "6.11 Copying and Pasting Text via pyperclip Module",
    "text": "6.11 Copying and Pasting Text via pyperclip Module\nTo copy and paste text from the clipboard in Python, you can use the pyperclip module. If you haven’t installed it yet, you can do so by running:\n# Run it in the bash / Python Interpreter / Terminal\npip install pyperclip\nOnce installed, you can use the following example to copy and paste text:\nimport pyperclip\n\n# Copy text to clipboard\ntext_to_copy = \"Hello, this is the text to copy!\"\npyperclip.copy(text_to_copy)\n\n# Paste text from clipboard\npasted_text = pyperclip.paste()\nprint(f\"Pasted text: {pasted_text}\")\nThis example demonstrates how to copy the string “Hello, this is the text to copy!” to the clipboard using pyperclip.copy() and then paste it using pyperclip.paste().\nMake sure your clipboard is accessible from the Python environment, as some environments (like certain IDEs or online platforms) may have restrictions on clipboard access. In a regular local Python environment, this should work as expected.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "ChatGPT Guide/prompt engineering basics.html#basic-initiating-phrases",
    "href": "ChatGPT Guide/prompt engineering basics.html#basic-initiating-phrases",
    "title": "10  Intro to ChatGPT",
    "section": "",
    "text": "Define the term along with a metaphor…\nExplain the purpose behind…\nDevelop a framework for…\nOutline the episodes for this podcast…\nAssist me in devising a budget plan for…\nOffer creative prompts to inspire my writing…\nGenerate 10 ideas to enhance the writing in this transcript…\nFormulate a well-organized chapter list for a book about…\nCompile recipes utilizing these ingredients…\nForm a catalog of topics related to…\nDevelop a lesson plan for…\nGenerate five headlines for…\nSummarize this book in a tweet…\nDevise a comprehensive strategy for social media content for…\nWrite an introductory email for outreach regarding…\nRecommend metaphors, analogies, or synonyms for…\nCreate a clever reply to this message…\nTurn this title into a captivating hook…\nTranslate this into the French language…\nCraft a polite response to decline this email…\nInvent an opening scene for a video featuring…\nPropose improvements to my resume…\nClarify the concept of…\nSuggest online courses or books to enhance…\nShare effective strategies for…\nOffer tips for starting my…\nRecommend nutritious meal options for…\nAssist in creating a daily schedule for…\nElaborate on the basics of…\nGuide on…",
    "crumbs": [
      "Mastering Prompt Engineering (ChatGPT)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Intro to ChatGPT</span>"
    ]
  },
  {
    "objectID": "ChatGPT Guide/prompt engineering basics.html#prompt-priming",
    "href": "ChatGPT Guide/prompt engineering basics.html#prompt-priming",
    "title": "10  Intro to ChatGPT",
    "section": "10.2 Prompt Priming",
    "text": "10.2 Prompt Priming\nPriming is refers to the practice of giving context to the model before generating response. It gives the model to get more desired response that are relevent and coherent with users intended output.\nWithout Priming: How can i learn machine learning? With Priming: I am student of Computer science and i gain various techs certification in the field. I have strong foundation of computer science & have the practicing knowledge of numerous programming knowledge which is, Python, C, C++, Java, Dart, Javascript etc. Now i want to dive into realm of machine learning from where can i start my journey?",
    "crumbs": [
      "Mastering Prompt Engineering (ChatGPT)",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Intro to ChatGPT</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#project-on-dictionary",
    "href": "1. python basics/6-string manipulation.html#project-on-dictionary",
    "title": "6  String Manipulations",
    "section": "6.12 Project on Dictionary",
    "text": "6.12 Project on Dictionary\nThe following program will extract the tip from the following dictionary and will show you on terminal only if you pass the corresponding key to the command-line argument. For Example: Write the following program in editor or Interpretor and call it from your terminal with python file name and one of the key from the following dictionary.\npython filename.py pruning\nAfter running the below program then check your clipboard to see the value of key pruning or press Win+vWin+v (shortcut for opening the clipboard directly)\nimport pyperclip, sys\n\ngardening_tips = {\n    'pruning': 'Remember to prune your plants regularly for healthy growth.',\n    'watering': 'Water your plants deeply but infrequently to encourage deep root growth.',\n    'fertilizing': 'Apply organic fertilizer to your garden beds in the spring for best results.'\n}\n\nif len(sys.argv)  &lt; 2:\n    print('You have not passed any argument & whatsoever')\n    sys.exit()\n\nkey = sys.argv[1] # Command line argument passed to terminal\n\nif key in gardening_tips:\n    pyperclip.copy(gardening_tips[key])\n    print('Text for ' + str(key) + ' copied to clipboard.')\n\nelse:\n    print('There is no text for ' + key)\nDevelop a program that extracts text from the clipboard, enhances it by making it bold for markdown formatting (using double asterisks), and subsequently pastes the formatted text back into the clipboard.\nFor Example: In our case i copied the following text to my clipboard\nSunset paints sky's canvas.\nCoffee fuels creative minds.\nBooks open new worlds.\nRobots learn, evolve daily.\nGardens bloom with care.\nSilence speaks, loud echoes.\nData shapes future innovations.\nCuriosity sparks endless discoveries.\nMusic transcends cultural boundaries.\nCoding simplifies complex problems.\nHere’s an explanation for each line of code with comments:\n# Import the pyperclip module for working with the clipboard\nimport pyperclip\n\n# Get the text from the clipboard, split it into lines, and remove '\\r' from each line\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\n# Initialize an empty string to store the modified phrases\nphrases = ''\n\n# Iterate through the list of strings\nfor sentence in list_of_strings:\n    # Check if the sentence is not an empty string\n    if sentence != '':\n        # Concatenate the modified sentence with '**' on both sides and a newline character\n        phrases += '**' + sentence + '**' + '\\n'\n\n# Copy the modified phrases back to the clipboard\npyperclip.copy(phrases)\nExplanation in details:\n\nImport pyperclip:\nimport pyperclip\nImport the pyperclip module, which provides a cross-platform interface for working with the clipboard.\nGet text from clipboard and process line endings:\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\npyperclip.paste(): Retrieve the text currently on the clipboard.\n.split('\\n'): Split the text into a list of strings based on newline characters.\n[line.rstrip('\\r') for line in ...]: Iterate through each line and remove trailing carriage return (\\r) characters, if any.\n\nInitialize an empty string for modified phrases:\nphrases = ''\nCreate an empty string phrases to store the modified sentences.\nIterate through the list of strings:\nfor sentence in list_of_strings:\nLoop through each line in the list of processed strings.\nCheck for non-empty sentences:\nif sentence != '':\nCheck if the current line (sentence) is not an empty string.\nModify and concatenate sentences:\nphrases += '**' + sentence + '**' + '\\n'\nConcatenate the modified sentence by adding ’**’ at the beginning and end, and include a newline character at the end.\nCopy the modified phrases back to the clipboard:\npyperclip.copy(phrases)\nUse pyperclip.copy to copy the modified phrases back to the clipboard, making them available for pasting elsewhere.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#project-1",
    "href": "1. python basics/6-string manipulation.html#project-1",
    "title": "6  String Manipulations",
    "section": "6.12 Project 1",
    "text": "6.12 Project 1\nThe following program will extract the tip from the following dictionary and will show you on the terminal only if you pass the corresponding key to the command-line argument. For Example: Write the following program in the editor or Interpreter and call it from your terminal with the Python file name and one of the keys from the following dictionary.\npython filename.py pruning\nAfter running the below program then check your clipboard to see the value of key pruning or press Win+vWin+v (shortcut for opening the clipboard directly)\nimport pyperclip, sys\n\ngardening_tips = {\n    'pruning': 'Remember to prune your plants regularly for healthy growth.',\n    'watering': 'Water your plants deeply but infrequently to encourage deep root growth.',\n    'fertilizing': 'Apply organic fertilizer to your garden beds in the spring for best results.'\n}\n\nif len(sys.argv)  &lt; 2:\n    print('You have not passed any argument & whatsoever')\n    sys.exit()\n\nkey = sys.argv[1] # Command line argument passed to terminal\n\nif key in gardening_tips:\n    pyperclip.copy(gardening_tips[key])\n    print('Text for ' + str(key) + ' copied to clipboard.')\n\nelse:\n    print('There is no text for ' + key)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#project-1-1",
    "href": "1. python basics/6-string manipulation.html#project-1-1",
    "title": "6  String Manipulations",
    "section": "6.13 Project 1",
    "text": "6.13 Project 1\nDevelop a program that extracts text from the clipboard, enhances it by making it bold for markdown formatting (using double asterisks), and subsequently pastes the formatted text back into the clipboard.\nFor Example: In our case i copied the following text to my clipboard\nSunset paints sky's canvas.\nCoffee fuels creative minds.\nBooks open new worlds.\nRobots learn, evolve daily.\nGardens bloom with care.\nSilence speaks, loud echoes.\nData shapes future innovations.\nCuriosity sparks endless discoveries.\nMusic transcends cultural boundaries.\nCoding simplifies complex problems.\nHere’s an explanation for each line of code with comments:\n# Import the pyperclip module for working with the clipboard\nimport pyperclip\n\n# Get the text from the clipboard, split it into lines, and remove '\\r' from each line\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\n# Initialize an empty string to store the modified phrases\nphrases = ''\n\n# Iterate through the list of strings\nfor sentence in list_of_strings:\n    # Check if the sentence is not an empty string\n    if sentence != '':\n        # Concatenate the modified sentence with '**' on both sides and a newline character\n        phrases += '**' + sentence + '**' + '\\n'\n\n# Copy the modified phrases back to the clipboard\npyperclip.copy(phrases)\nExplanation in details:\n\nImport pyperclip:\nimport pyperclip\nImport the pyperclip module, which provides a cross-platform interface for working with the clipboard.\nGet text from clipboard and process line endings:\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\npyperclip.paste(): Retrieve the text currently on the clipboard.\n.split('\\n'): Split the text into a list of strings based on newline characters.\n[line.rstrip('\\r') for line in ...]: Iterate through each line and remove trailing carriage return (\\r) characters, if any.\n\nInitialize an empty string for modified phrases:\nphrases = ''\nCreate an empty string phrases to store the modified sentences.\nIterate through the list of strings:\nfor sentence in list_of_strings:\nLoop through each line in the list of processed strings.\nCheck for non-empty sentences:\nif sentence != '':\nCheck if the current line (sentence) is not an empty string.\nModify and concatenate sentences:\nphrases += '**' + sentence + '**' + '\\n'\nConcatenate the modified sentence by adding ’**’ at the beginning and end, and include a newline character at the end.\nCopy the modified phrases back to the clipboard:\npyperclip.copy(phrases)\nUse pyperclip.copy to copy the modified phrases back to the clipboard, making them available for pasting elsewhere.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#project-2",
    "href": "1. python basics/6-string manipulation.html#project-2",
    "title": "6  String Manipulations",
    "section": "6.13 Project 2",
    "text": "6.13 Project 2\nDevelop a program that extracts text from the clipboard, enhances it by making it bold for markdown formatting (using double asterisks), and subsequently pastes the formatted text back into the clipboard.\nFor Example: In our case, I copied the following text to my clipboard\nSunset paints the sky's canvas.\nCoffee fuels creative minds.\nBooks open new worlds.\nRobots learn and evolve daily.\nGardens bloom with care.\nSilence speaks, loud echoes.\nData shapes future innovations.\nCuriosity sparks endless discoveries.\nMusic transcends cultural boundaries.\nCoding simplifies complex problems.\nHere’s an explanation for each line of code with comments:\n# Import the pyperclip module for working with the clipboard\nimport pyperclip\n\n# Get the text from the clipboard, split it into lines, and remove '\\r' from each line\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\n# Initialize an empty string to store the modified phrases\nphrases = ''\n\n# Iterate through the list of strings\nfor sentence in list_of_strings:\n    # Check if the sentence is not an empty string\n    if sentence != '':\n        # Concatenate the modified sentence with '**' on both sides and a newline character\n        phrases += '**' + sentence + '**' + '\\n'\n\n# Copy the modified phrases back to the clipboard\npyperclip.copy(phrases)\n\n\n\n\n\n\nClick to see alternative to the above program\n\n\n\n\n\nimport pyperclip\n\nlist_of_strings = [ line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\nphrases = ''\n\nphrases += '\\n'.join(list_of_strings)\n\npyperclip.copy(phrases)\n\n\n\nExplanation in details:\n\nImport pyperclip:\nimport pyperclip\nImport the pyperclip module, which provides a cross-platform interface for working with the clipboard.\nGet text from the clipboard and process line endings:\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\npyperclip.paste(): Retrieve the text currently on the clipboard.\n.split('\\n'): Split the text into a list of strings based on newline characters.\n[line.rstrip('\\r') for line in ...]: Iterate through each line and remove trailing carriage return (\\r) characters, if any.\n\nInitialize an empty string for modified phrases:\nphrases = ''\nCreate an empty string phrases to store the modified sentences.\nIterate through the list of strings:\nfor sentence in list_of_strings:\nLoop through each line in the list of processed strings.\nCheck for non-empty sentences:\nif sentence != '':\nCheck if the current line (sentence) is not an empty string.\nModify and concatenate sentences:\nphrases += '**' + sentence + '**' + '\\n'\nConcatenate the modified sentence by adding ’**’ at the beginning and end, and include a newline character at the end.\nCopy the modified phrases back to the clipboard:\npyperclip.copy(phrases)\nUse pyperclip.copy to copy the modified phrases back to the clipboard, making them available for pasting elsewhere.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#project-3",
    "href": "1. python basics/6-string manipulation.html#project-3",
    "title": "6  String Manipulations",
    "section": "6.14 Project 3",
    "text": "6.14 Project 3\nLet’s explore another linguistic transformation. This time, let’s delve into a playful language called “Double Trouble Language.” In this language:\n\nIf a word has an even number of letters, append “ee” to the end of the word.\nIf a word has an odd number of letters, double the last letter.\n\nFor example:\n\n“sun” becomes “sunn”\n“cloud” becomes “cloudd”\n“happy” becomes “happyy”\n“python” becomes “pythonee”\n\nNow, it’s quiz time! Transform the following words according to the rules of the Double Trouble Language:\n\n“moon”\n“butter”\n“apple”\n“coding”\n“elephant”\n\n\n\n\n\n\n\nClick to see the solution to the above project\n\n\n\n\n\nCertainly, Asad_Pro_Beta. Here’s an explanation for each line of code with comments:\n# Import the pprint module for pretty-printing dictionaries\nfrom pprint import pprint\n\n# List of words to be transformed\nwords = [\"moon\", \"butter\", \"apple\", \"coding\", \"elephant\"]\n\n# Initialize an empty list to store the transformed words\nupdate_words = []\n\n# Iterate through each word in the list\nfor word in words:\n    # Check if the length of the word is even\n    if len(word) % 2 == 0:\n        # If even, append 'ee' to the end of the word\n        update_words.append(word + 'ee')\n    else:\n        # If odd, double the last letter and append to the word\n        update_words.append(word + word[-1])\n\n# Creating a dictionary using zip, pairing original words with transformed words\nmy_dict = dict(zip(words, update_words))\n\n# Pretty-print the resulting dictionary\npprint(my_dict)\nStep-by-step explanation:\n\nImport the pprint module:\nfrom pprint import pprint\nImport the pprint function from the pprint module for pretty-printing dictionaries.\nList of words to be transformed:\nwords = [\"moon\", \"butter\", \"apple\", \"coding\", \"elephant\"]\nInitialize a list named words containing words to be transformed.\nInitialize an empty list for transformed words:\nupdate_words = []\nCreate an empty list named update_words to store the transformed words.\nIterate through each word:\nfor word in words:\nLoop through each word in the words list.\nCheck if the length of the word is even:\nif len(word) % 2 == 0:\nUse the len function to check if the length of the word is even.\nAppend ‘ee’ to even-length words, or double the last letter for odd-length words:\nupdate_words.append(word + 'ee')  # even-length\nIf the length is even, append ‘ee’ to the end of the word. Otherwise:\nupdate_words.append(word + word[-1])  # odd-length, double last letter\nIf the length is odd, double the last letter and append it to the word.\nCreating a dictionary using zip:\nmy_dict = dict(zip(words, update_words))\nUse the zip function to pair each original word with its transformed version, then create a dictionary (my_dict) from these pairs.\nPretty-print the resulting dictionary:\npprint(my_dict)\nUse pprint to display the resulting dictionary in a more readable format.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#practice-projects-1",
    "href": "1. python basics/6-string manipulation.html#practice-projects-1",
    "title": "6  String Manipulations",
    "section": "6.12 Practice Projects 1",
    "text": "6.12 Practice Projects 1\nThe following program will extract the tip from the following dictionary and will show you on the terminal only if you pass the corresponding key to the command-line argument. For Example: Write the following program in the editor or Interpreter and call it from your terminal with the Python file name and one of the keys from the following dictionary.\npython filename.py pruning\nAfter running the below program then check your clipboard to see the value of key pruning or press Win+vWin+v (shortcut for opening the clipboard directly)\nimport pyperclip, sys\n\ngardening_tips = {\n    'pruning': 'Remember to prune your plants regularly for healthy growth.',\n    'watering': 'Water your plants deeply but infrequently to encourage deep root growth.',\n    'fertilizing': 'Apply organic fertilizer to your garden beds in the spring for best results.'\n}\n\nif len(sys.argv)  &lt; 2:\n    print('You have not passed any argument & whatsoever')\n    sys.exit()\n\nkey = sys.argv[1] # Command line argument passed to terminal\n\nif key in gardening_tips:\n    pyperclip.copy(gardening_tips[key])\n    print('Text for ' + str(key) + ' copied to clipboard.')\n\nelse:\n    print('There is no text for ' + key)",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#practice-projects-2",
    "href": "1. python basics/6-string manipulation.html#practice-projects-2",
    "title": "6  String Manipulations",
    "section": "6.13 Practice Projects 2",
    "text": "6.13 Practice Projects 2\nDevelop a program that extracts text from the clipboard, enhances it by making it bold for markdown formatting (using double asterisks), and subsequently pastes the formatted text back into the clipboard.\nFor Example: In our case, I copied the following text to my clipboard\nSunset paints the sky's canvas.\nCoffee fuels creative minds.\nBooks open new worlds.\nRobots learn and evolve daily.\nGardens bloom with care.\nSilence speaks, loud echoes.\nData shapes future innovations.\nCuriosity sparks endless discoveries.\nMusic transcends cultural boundaries.\nCoding simplifies complex problems.\nHere’s an explanation for each line of code with comments:\n# Import the pyperclip module for working with the clipboard\nimport pyperclip\n\n# Get the text from the clipboard, split it into lines, and remove '\\r' from each line\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\n# Initialize an empty string to store the modified phrases\nphrases = ''\n\n# Iterate through the list of strings\nfor sentence in list_of_strings:\n    # Check if the sentence is not an empty string\n    if sentence != '':\n        # Concatenate the modified sentence with '**' on both sides and a newline character\n        phrases += '**' + sentence + '**' + '\\n'\n\n# Copy the modified phrases back to the clipboard\npyperclip.copy(phrases)\n\n\n\n\n\n\nClick to see alternative to the above program\n\n\n\n\n\nimport pyperclip\n\nlist_of_strings = [ line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\nphrases = ''\n\nphrases += '\\n'.join(list_of_strings)\n\npyperclip.copy(phrases)\n\n\n\nExplanation in details:\n\nImport pyperclip:\nimport pyperclip\nImport the pyperclip module, which provides a cross-platform interface for working with the clipboard.\nGet text from the clipboard and process line endings:\nlist_of_strings = [line.rstrip('\\r') for line in pyperclip.paste().split('\\n')]\n\npyperclip.paste(): Retrieve the text currently on the clipboard.\n.split('\\n'): Split the text into a list of strings based on newline characters.\n[line.rstrip('\\r') for line in ...]: Iterate through each line and remove trailing carriage return (\\r) characters, if any.\n\nInitialize an empty string for modified phrases:\nphrases = ''\nCreate an empty string phrases to store the modified sentences.\nIterate through the list of strings:\nfor sentence in list_of_strings:\nLoop through each line in the list of processed strings.\nCheck for non-empty sentences:\nif sentence != '':\nCheck if the current line (sentence) is not an empty string.\nModify and concatenate sentences:\nphrases += '**' + sentence + '**' + '\\n'\nConcatenate the modified sentence by adding ’**’ at the beginning and end, and include a newline character at the end.\nCopy the modified phrases back to the clipboard:\npyperclip.copy(phrases)\nUse pyperclip.copy to copy the modified phrases back to the clipboard, making them available for pasting elsewhere.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "1. python basics/6-string manipulation.html#practice-projects-3",
    "href": "1. python basics/6-string manipulation.html#practice-projects-3",
    "title": "6  String Manipulations",
    "section": "6.14 Practice Projects 3",
    "text": "6.14 Practice Projects 3\nLet’s explore another linguistic transformation. This time, let’s delve into a playful language called “Double Trouble Language.” In this language:\n\nIf a word has an even number of letters, append “ee” to the end of the word.\nIf a word has an odd number of letters, double the last letter.\n\nFor example:\n\n“sun” becomes “sunn”\n“cloud” becomes “cloudd”\n“happy” becomes “happyy”\n“python” becomes “pythonee”\n\nNow, it’s quiz time! Transform the following words according to the rules of the Double Trouble Language:\n\n“moon”\n“butter”\n“apple”\n“coding”\n“elephant”\n\n\n\n\n\n\n\nClick to see the solution to the above project\n\n\n\n\n\nCertainly, Asad_Pro_Beta. Here’s an explanation for each line of code with comments:\n# Import the pprint module for pretty-printing dictionaries\nfrom pprint import pprint\n\n# List of words to be transformed\nwords = [\"moon\", \"butter\", \"apple\", \"coding\", \"elephant\"]\n\n# Initialize an empty list to store the transformed words\nupdate_words = []\n\n# Iterate through each word in the list\nfor word in words:\n    # Check if the length of the word is even\n    if len(word) % 2 == 0:\n        # If even, append 'ee' to the end of the word\n        update_words.append(word + 'ee')\n    else:\n        # If odd, double the last letter and append to the word\n        update_words.append(word + word[-1])\n\n# Creating a dictionary using Zip, pairing original words with transformed words\nmy_dict = dict(zip(words, update_words))\n\n# Pretty-print the resulting dictionary\npprint(my_dict)\nStep-by-step explanation:\n\nImport the pprint module:\nfrom pprint import pprint\nImport the pprint function from the pprint module for pretty-printing dictionaries.\nList of words to be transformed:\nwords = [\"moon\", \"butter\", \"apple\", \"coding\", \"elephant\"]\nInitialize a list named words containing words to be transformed.\nInitialize an empty list for transformed words:\nupdate_words = []\nCreate an empty list named update_words to store the transformed words.\nIterate through each word:\nfor word in words:\nLoop through each word in the words list.\nCheck if the length of the word is even:\nif len(word) % 2 == 0:\nUse the len function to check if the length of the word is even.\nAppend ‘ee’ to even-length words, or double the last letter for odd-length words:\nupdate_words.append(word + 'ee')  # even-length\nIf the length is even, append ‘ee’ to the end of the word. Otherwise:\nupdate_words.append(word + word[-1])  # odd-length, double last letter\nIf the length is odd, double the last letter and append it to the word.\nCreating a dictionary using zip:\nmy_dict = dict(zip(words, update_words))\nUse the zip function to pair each original word with its transformed version, then create a dictionary (my_dict) from these pairs.\nPretty-print the resulting dictionary:\npprint(my_dict)\nUse pprint to display the resulting dictionary in a more readable format.",
    "crumbs": [
      "Python Programming Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>String Manipulations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html",
    "href": "2. Regular Expressions/pattern matching with regex.html",
    "title": "7  re — Regular expression operations",
    "section": "",
    "text": "A regular expression, often abbreviated as regex, is a sequence of characters that defines a search pattern. It’s a powerful tool used for string manipulation and matching patterns within text.\n\nSimple Analogy:\nLet’s think of a regular expression like a special search query. Imagine you have a magic magnifying glass, and you can define patterns or shapes you want to find in a book.\n\nBook (Text): Represents a piece of information, like a document or text data.\nMagnifying Glass (Regular Expression): Represents the tool that helps you search for specific patterns.\n\n\n\nIn Machine Learning:\n\nText Processing:\n\nIn natural language processing (NLP), regular expressions are used to extract specific information from text data. For example, finding all email addresses or dates in a document.\n\nData Cleaning:\n\nIn data preprocessing, regular expressions help clean and format data. For instance, removing special characters or formatting dates consistently.\n\n\n\n\nIn Daily Life:\n\nSearch Operations:\n\nHave you ever used Ctrl+F to find a word or phrase in a document? Regular expressions provide a more advanced version of this, allowing you to search for patterns like phone numbers or URLs.\n\nForm Validation:\n\nWhen you fill out a form online, the system might use regular expressions to check if you entered a valid email address, phone number, or other details.\n\n\n\n\nAnalogy Recap:\nJust like a magnifying glass helps you find specific shapes or patterns in a book, regular expressions help computers find specific patterns or structures in text. Whether it’s in machine learning for extracting information from data or in daily life for searching or validating information, regular expressions are a versatile tool for pattern matching.\n\n\nre.compile(), re.findall()\nThe compile method is useful when you want to search for the same pattern over and over again but if you need it only a single time then you can pass the pattern directly to that function as you will see in the upcoming lessons.\nimport re\n\nsentence = \"Hello123! This is a mixed-string example with @special# symbols 456 and characters.\"\n\n# Always pass a raw string to the pattern\npattern = r'\\d{3}'\n\n# Giving the above pattern to compile function so that it knows what to look\ncompiled = re.compile(pattern= pattern) \n\n# Use the compiled object on any string where you want to find the pattern you defined earlier.\nresult = re.findall(compiled, string = sentence)\n\nprint(result)\n\n\nre.search(pattern, string, flags=0)\n\npattern: This is the regular expression pattern you want to search for in the given string.\nstring: This is the input string where the search operation will be performed.\nflags: An optional parameter that can modify the behavior of the search. It’s typically set to 0.\n\n\nHow it works:\n\nThe re.search() method scans the entire string to find a match with the specified pattern.\nIf a match is found, it returns a match object; otherwise, it returns None.\n\n\n\nReal-life usage examples:\n\nValidation: You can use re.search() to validate whether a string adheres to a certain pattern. For example, checking if an email address or a phone number is in the correct format.\nimport re\n\nemail_pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\nemail = \"example@email.com\"\n\nif re.search(email_pattern, email):\n    print(\"Valid email address\")\nelse:\n    print(\"Invalid email address\")\nText extraction: When dealing with textual data, you can use regular expressions to extract specific information. For instance, extracting all the mentions from a tweet.\ntweet = \"Hey @user1 and @user2, how are you doing?\"\n\nmention_pattern = r'@([a-zA-Z0-9_]+)'\nmentions = re.findall(mention_pattern, tweet)\n\nprint(\"Mentions:\", mentions)\n\nThese are just a couple of examples, but re.search() is quite versatile and can be applied in various scenarios where you need to find or validate patterns within strings. If you have a specific use case in mind, feel free to let me know!\n\n\n\nre.match(pattern, string, flags=0)\n\npattern: The regular expression pattern to match at the beginning of the string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\nHow it works:\n\nThe re.match() method checks if the specified pattern matches at the beginning of the string.\nIf a match is found at the start of the string, it returns a match object; otherwise, it returns None.\n\n\n\nExample:\nLet’s say we want to check if a given string starts with the word “Hello”.\nimport re\n\npattern = r'Hello'\nstring1 = \"Hello, how are you?\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.match() to check if the pattern matches at the beginning of the string\nmatch1 = re.match(pattern, string1)\nmatch2 = re.match(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string1}\" does not start with \"Hello\"')\n\nif match2:\n    print(f'\"{string2}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string2}\" does not start with \"Hello\"')\nIn this example, match1 will be None because “Hello” is not at the very beginning of string1. However, match2 will be a match object because “Hello” is at the beginning of string2.\n\n\n\nre.fullmatch(pattern, string, flags=0)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\nHow it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n\nExample:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\n1pattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\n\n1\n\nThe regular expression ^[a-zA-Z0-9]+$ is a pattern commonly used to check if a string consists of only alphanumeric characters. Let’s break down the components of this regular expression:\n\n\n\n^: Asserts the start of the string.\n[a-zA-Z0-9]: Matches any uppercase letter (A-Z), lowercase letter (a-z), or digit (0-9). This character class ensures that only alphanumeric characters are allowed.\n+: Requires one or more occurrences of the preceding character class. This ensures that the string contains at least one alphanumeric character.\n$: Asserts the end of the string.\n\nSo, when you put it all together:\n\n^[a-zA-Z0-9]+$ ensures that the entire string consists of one or more alphanumeric characters, allowing no other characters in between.\n\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.\n\n\n\nre.findall(pattern, string, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nstring: The input string where the search operation will be performed.\nflags: Optional flags that can modify the behavior of the search.\n\n\nHow it works:\n\nThe re.findall() method scans the entire string to find all non-overlapping occurrences of the specified pattern.\nIt returns a list containing all the matches found.\n\n\n\nExample:\nLet’s say we want to find all the words in a string that start with the letter ‘C’. Here’s how you can use re.findall() for this:\nimport re\n\npattern = r'\\bC\\w*'  # Pattern for words starting with 'C'\nstring = \"Python is a cool programming language. Coder enjoys coding in C and Python.\"\n\nmatches = re.findall(pattern, string)\n\nprint(\"Words starting with 'C':\", matches)\nIn this example, the pattern r'\\bC\\w*' is used: - \\b: Word boundary to ensure that we match whole words. - C: The letter ‘C’ that the word should start with. - \\w*: Matches zero or more word characters (alphanumeric characters and underscores).\nThe re.findall() method searches the string for all occurrences of words that start with ‘C’ and returns a list containing those words. The output will be:\nWords starting with 'C': ['Cool', 'Coder', 'C', 'and']\n\n\n\nre.split(pattern, string, maxsplit=0, flags=0)\n\npattern: The regular expression pattern used for splitting the string.\nstring: The input string to be split.\nmaxsplit: An optional parameter that specifies the maximum number of splits. The default is 0, which means “all occurrences.”\nflags: Optional flags that can modify the behavior of the split.\n\n\nHow it works:\n\nThe re.split() method uses the specified pattern to identify positions in the string where the split should occur.\nIt returns a list of substrings resulting from the split.\n\n\n\nExample:\nLet’s say we want to split a string into words based on spaces and punctuation. Here’s how you can use re.split() for this:\nimport re\n\npattern = r'[ ,.?!]+'  # Pattern for one or more spaces, commas, periods, question marks, or exclamation marks\nstring = \"Hello, how are you? I hope everything is fine.\"\n\nresult = re.split(pattern, string)\n\nprint(\"Splitted words:\", result)\nIn this example, the pattern r'[ ,.?!]+' is used: - [ ,.?!]+: Matches one or more occurrences of spaces, commas, periods, question marks, or exclamation marks.\nThe re.split() method uses this pattern to split the string wherever it encounters one or more of these characters. The output will be:\nSplitted words: ['Hello', 'how', 'are', 'you', 'I', 'hope', 'everything', 'is', 'fine', '']\nThe resulting list contains individual words from the original string, excluding spaces and punctuation.\n\n\n\nre.sub(pattern, replacement, string, count=0, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.\n\n\nHow it works:\n\nThe re.sub() method searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nThe modified string is then returned.\n\n\n\nExample:\nLet’s say we want to replace all occurrences of the word “apple” with “orange” in a given string. Here’s how you can use re.sub() for this:\nimport re\n\npattern = r'apple'  # Pattern to search for\nreplacement = 'orange'  # String to replace the matched occurrences\nstring = \"I have an apple, and she has an apple too. We all love apples!\"\n\nresult = re.sub(pattern, replacement, string)\n\nprint(\"Modified string:\", result)\nIn this example, the re.sub() method searches for all occurrences of the pattern ‘apple’ in the string and replaces each occurrence with ‘orange’. The output will be:\nModified string: I have an orange, and she has an orange too. We all love oranges!\n\n\n\nre.subn(pattern, replacement, string, count=0, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.\n\n\nHow it works:\n\nThe re.subn() method is similar to re.sub(); it searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nIt returns a tuple containing the modified string and the count of substitutions made.\n\n\n\nExample:\nLet’s modify the previous example slightly to use re.subn() and see the count of substitutions:\nimport re\n\npattern = r'password'  # Pattern to search for\nreplacement = '***'     # String to replace the matched occurrences\ntext = \"Please enter your password to proceed. Your password is case-sensitive.\"\n\nresult, count = re.subn(pattern, replacement, text)\n\nprint(\"Modified text:\", result)\nprint(\"Number of substitutions:\", count)\nIn this example, the output will be:\nModified text: Please enter your *** to proceed. Your *** is case-sensitive.\nNumber of substitutions: 2\nThe re.subn() method not only returns the modified string (result) but also the count of substitutions (count). In this case, it tells us that two substitutions were made for the pattern ‘password’ in the original text. This can be useful when you want to know how many replacements were performed.\n\n\n\nConcise Overview of re Modules:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nre.search()\nSearches for a specified pattern within a string and returns a match object if found, otherwise returns None.\n\n\nre.match()\nChecks if a specified pattern matches at the beginning of a string and returns a match object if successful, otherwise returns None.\n\n\nre.fullmatch()\nDetermines if the entire string matches a given pattern and returns a match object if successful, otherwise returns None.\n\n\nre.findall()\nFinds all occurrences of a specified pattern in a string and returns them as a list.\n\n\nre.split()\nSplits a string into a list of substrings based on a specified regular expression pattern.\n\n\nre.sub()\nReplaces occurrences of a specified pattern in a string with a specified replacement and returns the modified string.\n\n\nre.subn()\nSimilar to re.sub(), but also returns the count of substitutions made along with the modified string.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#section",
    "href": "2. Regular Expressions/pattern matching with regex.html#section",
    "title": "7  re — Regular expression operations",
    "section": "7.1 ",
    "text": "7.1 \nThe re.fullmatch() method in Python is used to determine if the entire string matches a given pattern. Here’s a detailed breakdown of its usage:\n\n7.1.1 re.fullmatch(pattern, string, flags=0)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\n7.1.1.1 How it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n\n7.1.1.2 Example:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\npattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.\nThe re.fullmatch() method is useful when you want to ensure that the entire string adheres to a specific pattern. If you have any further questions or if there’s a particular pattern you’d like to explore, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#re.match-method",
    "href": "2. Regular Expressions/pattern matching with regex.html#re.match-method",
    "title": "7  re — Regular expression operations",
    "section": "re.match() method",
    "text": "re.match() method\nre.match() method search for a match at the beginning of a string if it found it. It will return that match else it would return None. Here’s an explanation along with an example:\n\nre.match(pattern, string, flags=0)\n\npattern: The regular expression pattern to match at the beginning of the string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\nHow it works:\n\nThe re.match() method checks if the specified pattern matches at the beginning of the string.\nIf a match is found at the start of the string, it returns a match object; otherwise, it returns None.\n\n\n\nExample:\nLet’s say we want to check if a given string starts with the word “Hello”.\nimport re\n\npattern = r'Hello'\nstring1 = \"Hello, how are you?\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.match() to check if the pattern matches at the beginning of the string\nmatch1 = re.match(pattern, string1)\nmatch2 = re.match(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string1}\" does not start with \"Hello\"')\n\nif match2:\n    print(f'\"{string2}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string2}\" does not start with \"Hello\"')\nIn this example, match1 will be None because “Hello” is not at the very beginning of string1. However, match2 will be a match object because “Hello” is at the beginning of string2.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#re.search-method",
    "href": "2. Regular Expressions/pattern matching with regex.html#re.search-method",
    "title": "7  re — Regular expression operations",
    "section": "re.search() method",
    "text": "re.search() method\nThe re.search() method is part of the Python re (regular expression) module, and it’s used for searching a string for a match with a regular expression pattern. Here’s a breakdown of its functionality:\n\nre.search(pattern, string, flags=0)\n\npattern: This is the regular expression pattern you want to search for in the given string.\nstring: This is the input string where the search operation will be performed.\nflags: An optional parameter that can modify the behavior of the search. It’s typically set to 0.\n\n\nHow it works:\n\nThe re.search() method scans the entire string to find a match with the specified pattern.\nIf a match is found, it returns a match object; otherwise, it returns None.\n\n\n\nReal-life usage examples:\n\nValidation: You can use re.search() to validate whether a string adheres to a certain pattern. For example, checking if an email address or a phone number is in the correct format.\nimport re\n\nemail_pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\nemail = \"example@email.com\"\n\nif re.search(email_pattern, email):\n    print(\"Valid email address\")\nelse:\n    print(\"Invalid email address\")\nText extraction: When dealing with textual data, you can use regular expressions to extract specific information. For instance, extracting all the mentions from a tweet.\ntweet = \"Hey @user1 and @user2, how are you doing?\"\n\nmention_pattern = r'@([a-zA-Z0-9_]+)'\nmentions = re.findall(mention_pattern, tweet)\n\nprint(\"Mentions:\", mentions)\n\nThese are just a couple of examples, but re.search() is quite versatile and can be applied in various scenarios where you need to find or validate patterns within strings. If you have a specific use case in mind, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#re.fullmatch",
    "href": "2. Regular Expressions/pattern matching with regex.html#re.fullmatch",
    "title": "7  re — Regular expression operations",
    "section": "7.1 re.fullmatch()",
    "text": "7.1 re.fullmatch()\nThe re.fullmatch() method in Python is used to determine if the entire string matches a given pattern. Here’s a detailed breakdown of its usage:\n\n7.1.1 re.fullmatch(pattern, string, flags=0)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\n7.1.1.1 How it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n\n7.1.1.2 Example:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\npattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.\nThe re.fullmatch() method is useful when you want to ensure that the entire string adheres to a specific pattern. If you have any further questions or if there’s a particular pattern you’d like to explore, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#re.fullmatch-method",
    "href": "2. Regular Expressions/pattern matching with regex.html#re.fullmatch-method",
    "title": "7  re — Regular expression operations",
    "section": "re.fullmatch() method",
    "text": "re.fullmatch() method\nThe re.fullmatch() method in Python is used to determine if the entire string matches a given pattern. Here’s a detailed breakdown of its usage:\n\nre.fullmatch(pattern, string, flags=0)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\nHow it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n\nExample:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\n1pattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\n\n1\n\nThe regular expression ^[a-zA-Z0-9]+$ is a pattern commonly used to check if a string consists of only alphanumeric characters. Let’s break down the components of this regular expression:\n\n\n\n^: Asserts the start of the string.\n[a-zA-Z0-9]: Matches any uppercase letter (A-Z), lowercase letter (a-z), or digit (0-9). This character class ensures that only alphanumeric characters are allowed.\n+: Requires one or more occurrences of the preceding character class. This ensures that the string contains at least one alphanumeric character.\n$: Asserts the end of the string.\n\nSo, when you put it all together:\n\n^[a-zA-Z0-9]+$ ensures that the entire string consists of one or more alphanumeric characters, allowing no other characters in between.\n\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/pattern matching with regex.html#footnotes",
    "href": "2. Regular Expressions/pattern matching with regex.html#footnotes",
    "title": "7  re — Regular expression operations",
    "section": "",
    "text": "a-zA-Z0-9↩︎",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html",
    "href": "2. Regular Expressions/2. regex metacharacters.html",
    "title": "8  Metacharacters & Special Sequences",
    "section": "",
    "text": "8.1 Metacharacters:",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html",
    "href": "2. Regular Expressions/1. regex modules.html",
    "title": "7  re — Regular expression operations",
    "section": "",
    "text": "Simple Analogy:\nLet’s think of a regular expression like a special search query. Imagine you have a magic magnifying glass, and you can define patterns or shapes you want to find in a book.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.compile-re.findall",
    "href": "2. Regular Expressions/1. regex modules.html#re.compile-re.findall",
    "title": "7  re — Regular expression operations",
    "section": "7.1 re.compile(), re.findall()",
    "text": "7.1 re.compile(), re.findall()\nThe compile method is useful when you want to search for the same pattern over and over again but if you need it only a single time then you can pass the pattern directly to that function as you will see in the upcoming lessons.\nimport re\n\nsentence = \"Hello123! This is a mixed-string example with @special# symbols 456 and characters.\"\n\n# Always pass a raw string to the pattern\npattern = r'\\d{3}'\n\n# Giving the above pattern to compile function so that it knows what to look\ncompiled = re.compile(pattern= pattern) \n\n# Use the compiled object on any string where you want to find the pattern you defined earlier.\nresult = re.findall(compiled, string = sentence)\n\nprint(result)",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.searchpattern-string-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.searchpattern-string-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.2 re.search(pattern, string, flags=0)",
    "text": "7.2 re.search(pattern, string, flags=0)\n\npattern: This is the regular expression pattern you want to search for in the given string.\nstring: This is the input string where the search operation will be performed.\nflags: An optional parameter that can modify the behavior of the search. It’s typically set to 0.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.matchpattern-string-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.matchpattern-string-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.3 re.match(pattern, string, flags=0)",
    "text": "7.3 re.match(pattern, string, flags=0)\n\npattern: The regular expression pattern to match at the beginning of the string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.fullmatchpattern-string-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.fullmatchpattern-string-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.4 re.fullmatch(pattern, string, flags=0)",
    "text": "7.4 re.fullmatch(pattern, string, flags=0)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.findallpattern-string-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.findallpattern-string-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.5 re.findall(pattern, string, flags=0)",
    "text": "7.5 re.findall(pattern, string, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nstring: The input string where the search operation will be performed.\nflags: Optional flags that can modify the behavior of the search.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.splitpattern-string-maxsplit0-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.splitpattern-string-maxsplit0-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.6 re.split(pattern, string, maxsplit=0, flags=0)",
    "text": "7.6 re.split(pattern, string, maxsplit=0, flags=0)\n\npattern: The regular expression pattern used for splitting the string.\nstring: The input string to be split.\nmaxsplit: An optional parameter that specifies the maximum number of splits. The default is 0, which means “all occurrences.”\nflags: Optional flags that can modify the behavior of the split.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.subpattern-replacement-string-count0-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.subpattern-replacement-string-count0-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.7 re.sub(pattern, replacement, string, count=0, flags=0)",
    "text": "7.7 re.sub(pattern, replacement, string, count=0, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.subnpattern-replacement-string-count0-flags0",
    "href": "2. Regular Expressions/1. regex modules.html#re.subnpattern-replacement-string-count0-flags0",
    "title": "7  re — Regular expression operations",
    "section": "7.8 re.subn(pattern, replacement, string, count=0, flags=0)",
    "text": "7.8 re.subn(pattern, replacement, string, count=0, flags=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#concise-overview-of-re-modules",
    "href": "2. Regular Expressions/1. regex modules.html#concise-overview-of-re-modules",
    "title": "7  re — Regular expression operations",
    "section": "7.9 Concise Overview of re Modules:",
    "text": "7.9 Concise Overview of re Modules:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nre.search()\nSearches for a specified pattern within a string and returns a match object if found, otherwise returns None.\n\n\nre.match()\nChecks if a specified pattern matches at the beginning of a string and returns a match object if successful, otherwise returns None.\n\n\nre.fullmatch()\nDetermines if the entire string matches a given pattern and returns a match object if successful, otherwise returns None.\n\n\nre.findall()\nFinds all occurrences of a specified pattern in a string and returns them as a list.\n\n\nre.split()\nSplits a string into a list of substrings based on a specified regular expression pattern.\n\n\nre.sub()\nReplaces occurrences of a specified pattern in a string with a specified replacement and returns the modified string.\n\n\nre.subn()\nSimilar to re.sub(), but also returns the count of substitutions made along with the modified string.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.searchpattern-string",
    "href": "2. Regular Expressions/1. regex modules.html#re.searchpattern-string",
    "title": "7  re — Regular expression operations",
    "section": "7.2 re.search(pattern, string)",
    "text": "7.2 re.search(pattern, string)\n\npattern: This is the regular expression pattern you want to search for in the given string.\nstring: This is the input string where the search operation will be performed.\nflags: An optional parameter that can modify the behavior of the search. It’s typically set to 0.\n\n\n7.2.1 How it works:\n\nThe re.search() method scans the entire string to find a match with the specified pattern.\nIf a match is found, it returns a match object; otherwise, it returns None.\n\n\n\n7.2.2 Real-life usage examples:\n\nValidation: You can use re.search() to validate whether a string adheres to a certain pattern. For example, checking if an email address or a phone number is in the correct format.\nimport re\n\nemail_pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\nemail = \"example@email.com\"\n\nif re.search(email_pattern, email):\n    print(\"Valid email address\")\nelse:\n    print(\"Invalid email address\")\nText extraction: When dealing with textual data, you can use regular expressions to extract specific information. For instance, extracting all the mentions from a tweet.\ntweet = \"Hey @user1 and @user2, how are you doing?\"\n\nmention_pattern = r'@([a-zA-Z0-9_]+)'\nmentions = re.findall(mention_pattern, tweet)\n\nprint(\"Mentions:\", mentions)\n\nThese are just a couple of examples, but re.search() is quite versatile and can be applied in various scenarios where you need to find or validate patterns within strings. If you have a specific use case in mind, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.matchpattern-string",
    "href": "2. Regular Expressions/1. regex modules.html#re.matchpattern-string",
    "title": "7  re — Regular expression operations",
    "section": "7.3 re.match(pattern, string)",
    "text": "7.3 re.match(pattern, string)\n\npattern: The regular expression pattern to match at the beginning of the string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\n7.3.1 How it works:\n\nThe re.match() method checks if the specified pattern matches at the beginning of the string.\nIf a match is found at the start of the string, it returns a match object; otherwise, it returns None.\n\n\n\n7.3.2 Example:\nLet’s say we want to check if a given string starts with the word “Hello”.\nimport re\n\npattern = r'Hello'\nstring1 = \"Hello, how are you?\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.match() to check if the pattern matches at the beginning of the string\nmatch1 = re.match(pattern, string1)\nmatch2 = re.match(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string1}\" does not start with \"Hello\"')\n\nif match2:\n    print(f'\"{string2}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string2}\" does not start with \"Hello\"')\nIn this example, match1 will be None because “Hello” is not at the very beginning of string1. However, match2 will be a match object because “Hello” is at the beginning of string2.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.fullmatchpattern-string",
    "href": "2. Regular Expressions/1. regex modules.html#re.fullmatchpattern-string",
    "title": "7  re — Regular expression operations",
    "section": "7.4 re.fullmatch(pattern, string)",
    "text": "7.4 re.fullmatch(pattern, string)\n\npattern: The regular expression pattern to match against the entire string.\nstring: The input string where the match operation will be performed.\nflags: Optional flags that can modify the behavior of the match.\n\n\n7.4.1 How it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n\n7.4.2 Example:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\n1pattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\n\n1\n\nThe regular expression ^[a-zA-Z0-9]+$ is a pattern commonly used to check if a string consists of only alphanumeric characters. Let’s break down the components of this regular expression:\n\n\n\n^: Asserts the start of the string.\n[a-zA-Z0-9]: Matches any uppercase letter (A-Z), lowercase letter (a-z), or digit (0-9). This character class ensures that only alphanumeric characters are allowed.\n+: Requires one or more occurrences of the preceding character class. This ensures that the string contains at least one alphanumeric character.\n$: Asserts the end of the string.\n\nSo, when you put it all together:\n\n^[a-zA-Z0-9]+$ ensures that the entire string consists of one or more alphanumeric characters, allowing no other characters in between.\n\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.findallpattern-string",
    "href": "2. Regular Expressions/1. regex modules.html#re.findallpattern-string",
    "title": "7  re — Regular expression operations",
    "section": "7.5 re.findall(pattern, string)",
    "text": "7.5 re.findall(pattern, string)\n\npattern: The regular expression pattern to search for in the string.\nstring: The input string where the search operation will be performed.\nflags: Optional flags that can modify the behavior of the search.\n\n\n7.5.1 How it works:\n\nThe re.findall() method scans the entire string to find all non-overlapping occurrences of the specified pattern.\nIt returns a list containing all the matches found.\n\n\n\n7.5.2 Example:\nLet’s say we want to find all the words in a string that start with the letter ‘C’. Here’s how you can use re.findall() for this:\nimport re\n\npattern = r'\\bC\\w*'  # Pattern for words starting with 'C'\nstring = \"Python is a cool programming language. Coder enjoys coding in C and Python.\"\n\nmatches = re.findall(pattern, string)\n\nprint(\"Words starting with 'C':\", matches)\nIn this example, the pattern r'\\bC\\w*' is used: - \\b: Word boundary to ensure that we match whole words. - C: The letter ‘C’ that the word should start with. - \\w*: Matches zero or more word characters (alphanumeric characters and underscores).\nThe re.findall() method searches the string for all occurrences of words that start with ‘C’ and returns a list containing those words. The output will be:\nWords starting with 'C': ['Cool', 'Coder', 'C', 'and']",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.splitpattern-string-maxsplit0",
    "href": "2. Regular Expressions/1. regex modules.html#re.splitpattern-string-maxsplit0",
    "title": "7  re — Regular expression operations",
    "section": "7.6 re.split(pattern, string, maxsplit=0)",
    "text": "7.6 re.split(pattern, string, maxsplit=0)\n\npattern: The regular expression pattern used for splitting the string.\nstring: The input string to be split.\nmaxsplit: An optional parameter that specifies the maximum number of splits. The default is 0, which means “all occurrences.”\nflags: Optional flags that can modify the behavior of the split.\n\n\n7.6.1 How it works:\n\nThe re.split() method uses the specified pattern to identify positions in the string where the split should occur.\nIt returns a list of substrings resulting from the split.\n\n\n\n7.6.2 Example:\nLet’s say we want to split a string into words based on spaces and punctuation. Here’s how you can use re.split() for this:\nimport re\n\npattern = r'[ ,.?!]+'  # Pattern for one or more spaces, commas, periods, question marks, or exclamation marks\nstring = \"Hello, how are you? I hope everything is fine.\"\n\nresult = re.split(pattern, string)\n\nprint(\"Splitted words:\", result)\nIn this example, the pattern r'[ ,.?!]+' is used: - [ ,.?!]+: Matches one or more occurrences of spaces, commas, periods, question marks, or exclamation marks.\nThe re.split() method uses this pattern to split the string wherever it encounters one or more of these characters. The output will be:\nSplitted words: ['Hello', 'how', 'are', 'you', 'I', 'hope', 'everything', 'is', 'fine', '']\nThe resulting list contains individual words from the original string, excluding spaces and punctuation.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.subpattern-replacement-string-count0",
    "href": "2. Regular Expressions/1. regex modules.html#re.subpattern-replacement-string-count0",
    "title": "7  re — Regular expression operations",
    "section": "7.7 re.sub(pattern, replacement, string, count=0)",
    "text": "7.7 re.sub(pattern, replacement, string, count=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.\n\n\n7.7.1 How it works:\n\nThe re.sub() method searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nThe modified string is then returned.\n\n\n\n7.7.2 Example:\nLet’s say we want to replace all occurrences of the word “apple” with “orange” in a given string. Here’s how you can use re.sub() for this:\nimport re\n\npattern = r'apple'  # Pattern to search for\nreplacement = 'orange'  # String to replace the matched occurrences\nstring = \"I have an apple, and she has an apple too. We all love apples!\"\n\nresult = re.sub(pattern, replacement, string)\n\nprint(\"Modified string:\", result)\nIn this example, the re.sub() method searches for all occurrences of the pattern ‘apple’ in the string and replaces each occurrence with ‘orange’. The output will be:\nModified string: I have an orange, and she has an orange too. We all love oranges!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#re.subnpattern-replacement-string-count0",
    "href": "2. Regular Expressions/1. regex modules.html#re.subnpattern-replacement-string-count0",
    "title": "7  re — Regular expression operations",
    "section": "7.8 re.subn(pattern, replacement, string, count=0)",
    "text": "7.8 re.subn(pattern, replacement, string, count=0)\n\npattern: The regular expression pattern to search for in the string.\nreplacement: The string to replace the matched occurrences of the pattern.\nstring: The input string where the substitutions will be performed.\ncount: An optional parameter that specifies the maximum number of substitutions to make. The default is 0, which means “replace all occurrences.”\nflags: Optional flags that can modify the behavior of the substitution.\n\n\n7.8.1 How it works:\n\nThe re.subn() method is similar to re.sub(); it searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nIt returns a tuple containing the modified string and the count of substitutions made.\n\n\n\n7.8.2 Example:\nLet’s modify the previous example slightly to use re.subn() and see the count of substitutions:\nimport re\n\npattern = r'password'  # Pattern to search for\nreplacement = '***'     # String to replace the matched occurrences\ntext = \"Please enter your password to proceed. Your password is case-sensitive.\"\n\nresult, count = re.subn(pattern, replacement, text)\n\nprint(\"Modified text:\", result)\nprint(\"Number of substitutions:\", count)\nIn this example, the output will be:\nModified text: Please enter your *** to proceed. Your *** is case-sensitive.\nNumber of substitutions: 2\nThe re.subn() method not only returns the modified string (result) but also the count of substitutions (count). In this case, it tells us that two substitutions were made for the pattern ‘password’ in the original text. This can be useful when you want to know how many replacements were performed.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.search() method scans the entire string to find a match with the specified pattern.\nIf a match is found, it returns a match object; otherwise, it returns None.\n\n\n7.2.1 Real-life usage examples:\n\nValidation: You can use re.search() to validate whether a string adheres to a certain pattern. For example, checking if an email address or a phone number is in the correct format.\nimport re\n\nemail_pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\nemail = \"example@email.com\"\n\nif re.search(email_pattern, email):\n    print(\"Valid email address\")\nelse:\n    print(\"Invalid email address\")\nText extraction: When dealing with textual data, you can use regular expressions to extract specific information. For instance, extracting all the mentions from a tweet.\ntweet = \"Hey @user1 and @user2, how are you doing?\"\n\nmention_pattern = r'@([a-zA-Z0-9_]+)'\nmentions = re.findall(mention_pattern, tweet)\n\nprint(\"Mentions:\", mentions)\n\nThese are just a couple of examples, but re.search() is quite versatile and can be applied in various scenarios where you need to find or validate patterns within strings. If you have a specific use case in mind, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-1",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-1",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.match() method checks if the specified pattern matches at the beginning of the string.\nIf a match is found at the start of the string, it returns a match object; otherwise, it returns None.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-2",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-2",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.fullmatch() method checks if the specified pattern matches the entire string.\nIf a match is found for the entire string, it returns a match object; otherwise, it returns None.\n\n\n7.4.1 Example:\nLet’s consider an example where we want to check if a string consists of only alphanumeric characters:\nimport re\n\n1pattern = r'^[a-zA-Z0-9]+$'  # Pattern for alphanumeric string\nstring1 = \"Hello123\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.fullmatch() to check if the pattern matches the entire string\nmatch1 = re.fullmatch(pattern, string1)\nmatch2 = re.fullmatch(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string1}\" is not a valid alphanumeric string.')\n\nif match2:\n    print(f'\"{string2}\" is a valid alphanumeric string.')\nelse:\n    print(f'\"{string2}\" is not a valid alphanumeric string.')\n\n1\n\nThe regular expression ^[a-zA-Z0-9]+$ is a pattern commonly used to check if a string consists of only alphanumeric characters. Let’s break down the components of this regular expression:\n\n\n\n^: Asserts the start of the string.\n[a-zA-Z0-9]: Matches any uppercase letter (A-Z), lowercase letter (a-z), or digit (0-9). This character class ensures that only alphanumeric characters are allowed.\n+: Requires one or more occurrences of the preceding character class. This ensures that the string contains at least one alphanumeric character.\n$: Asserts the end of the string.\n\nSo, when you put it all together:\n\n^[a-zA-Z0-9]+$ ensures that the entire string consists of one or more alphanumeric characters, allowing no other characters in between.\n\nIn this example, match1 will be a match object because “Hello123” consists of only alphanumeric characters, and it matches the entire pattern. However, match2 will be None because “Hi there, Hello!” contains non-alphanumeric characters and doesn’t match the entire pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-3",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-3",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.findall() method scans the entire string to find all non-overlapping occurrences of the specified pattern.\nIt returns a list containing all the matches found.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-4",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-4",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.split() method uses the specified pattern to identify positions in the string where the split should occur.\nIt returns a list of substrings resulting from the split.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-5",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-5",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.sub() method searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nThe modified string is then returned.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#how-it-works-6",
    "href": "2. Regular Expressions/1. regex modules.html#how-it-works-6",
    "title": "7  re — Regular expression operations",
    "section": "How it works:",
    "text": "How it works:\n\nThe re.subn() method is similar to re.sub(); it searches for all occurrences of the specified pattern in the string.\nIt replaces each occurrence with the specified replacement string.\nIt returns a tuple containing the modified string and the count of substitutions made.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#example",
    "href": "2. Regular Expressions/1. regex modules.html#example",
    "title": "7  re — Regular expression operations",
    "section": "Example:",
    "text": "Example:\nLet’s say we want to check if a given string starts with the word “Hello”.\nimport re\n\npattern = r'Hello'\nstring1 = \"Hello, how are you?\"\nstring2 = \"Hi there, Hello!\"\n\n# Using re.match() to check if the pattern matches at the beginning of the string\nmatch1 = re.match(pattern, string1)\nmatch2 = re.match(pattern, string2)\n\n# Checking the results\nif match1:\n    print(f'\"{string1}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string1}\" does not start with \"Hello\"')\n\nif match2:\n    print(f'\"{string2}\" starts with \"Hello\"')\nelse:\n    print(f'\"{string2}\" does not start with \"Hello\"')\nIn this example, match1 will be None because “Hello” is not at the very beginning of string1. However, match2 will be a match object because “Hello” is at the beginning of string2.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#example-2",
    "href": "2. Regular Expressions/1. regex modules.html#example-2",
    "title": "7  re — Regular expression operations",
    "section": "Example:",
    "text": "Example:\nLet’s say we want to find all the words in a string that start with the letter ‘C’. Here’s how you can use re.findall() for this:\nimport re\n\npattern = r'\\bC\\w*'  # Pattern for words starting with 'C'\nstring = \"Python is a cool programming language. Coder enjoys coding in C and Python.\"\n\nmatches = re.findall(pattern, string)\n\nprint(\"Words starting with 'C':\", matches)\nIn this example, the pattern r'\\bC\\w*' is used: - \\b: Word boundary to ensure that we match whole words. - C: The letter ‘C’ that the word should start with. - \\w*: Matches zero or more word characters (alphanumeric characters and underscores).\nThe re.findall() method searches the string for all occurrences of words that start with ‘C’ and returns a list containing those words. The output will be:\nWords starting with 'C': ['Cool', 'Coder', 'C', 'and']",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#example-3",
    "href": "2. Regular Expressions/1. regex modules.html#example-3",
    "title": "7  re — Regular expression operations",
    "section": "Example:",
    "text": "Example:\nLet’s say we want to split a string into words based on spaces and punctuation. Here’s how you can use re.split() for this:\nimport re\n\npattern = r'[ ,.?!]+'  # Pattern for one or more spaces, commas, periods, question marks, or exclamation marks\nstring = \"Hello, how are you? I hope everything is fine.\"\n\nresult = re.split(pattern, string)\n\nprint(\"Splitted words:\", result)\nIn this example, the pattern r'[ ,.?!]+' is used: - [ ,.?!]+: Matches one or more occurrences of spaces, commas, periods, question marks, or exclamation marks.\nThe re.split() method uses this pattern to split the string wherever it encounters one or more of these characters. The output will be:\nSplitted words: ['Hello', 'how', 'are', 'you', 'I', 'hope', 'everything', 'is', 'fine', '']\nThe resulting list contains individual words from the original string, excluding spaces and punctuation.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#example-4",
    "href": "2. Regular Expressions/1. regex modules.html#example-4",
    "title": "7  re — Regular expression operations",
    "section": "Example:",
    "text": "Example:\nLet’s say we want to replace all occurrences of the word “apple” with “orange” in a given string. Here’s how you can use re.sub() for this:\nimport re\n\npattern = r'apple'  # Pattern to search for\nreplacement = 'orange'  # String to replace the matched occurrences\nstring = \"I have an apple, and she has an apple too. We all love apples!\"\n\nresult = re.sub(pattern, replacement, string)\n\nprint(\"Modified string:\", result)\nIn this example, the re.sub() method searches for all occurrences of the pattern ‘apple’ in the string and replaces each occurrence with ‘orange’. The output will be:\nModified string: I have an orange, and she has an orange too. We all love oranges!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/1. regex modules.html#example-5",
    "href": "2. Regular Expressions/1. regex modules.html#example-5",
    "title": "7  re — Regular expression operations",
    "section": "Example:",
    "text": "Example:\nLet’s modify the previous example slightly to use re.subn() and see the count of substitutions:\nimport re\n\npattern = r'password'  # Pattern to search for\nreplacement = '***'     # String to replace the matched occurrences\ntext = \"Please enter your password to proceed. Your password is case-sensitive.\"\n\nresult, count = re.subn(pattern, replacement, text)\n\nprint(\"Modified text:\", result)\nprint(\"Number of substitutions:\", count)\nIn this example, the output will be:\nModified text: Please enter your *** to proceed. Your *** is case-sensitive.\nNumber of substitutions: 2\nThe re.subn() method not only returns the modified string (result) but also the count of substitutions (count). In this case, it tells us that two substitutions were made for the pattern ‘password’ in the original text. This can be useful when you want to know how many replacements were performed.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`re` — Regular expression operations</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#metacharacters",
    "href": "2. Regular Expressions/2. regex metacharacters.html#metacharacters",
    "title": "8  Metacharacters & Special Sequences",
    "section": "",
    "text": ". (Dot): Matches any character except a newline.\n^: Anchors the regex at the start of the string.\n$: Anchors the regex at the end of the string.\n*: Matches 0 or more occurrences of the preceding character.\n+: Matches 1 or more occurrences of the preceding character.\n?: Matches 0 or 1 occurrence of the preceding character.\n| (Pipe): Acts as an OR operator, allowing multiple patterns.\n() (Parentheses): Groups patterns together.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#special-sequences",
    "href": "2. Regular Expressions/2. regex metacharacters.html#special-sequences",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.2 Special Sequences:",
    "text": "8.2 Special Sequences:\n\n\\d: Matches any digit (equivalent to [0-9]).\n\\D: Matches any non-digit character.\n\\w: Matches any alphanumeric character (equivalent to [a-zA-Z0-9_]).\n\\W: Matches any non-alphanumeric character.\n\\s: Matches any whitespace character (space, tab, newline).\n\\S: Matches any non-whitespace character.\n\\b: Matches a word boundary.\n\\B: Matches a non-word boundary.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#other-names",
    "href": "2. Regular Expressions/2. regex metacharacters.html#other-names",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.3 Other Names:",
    "text": "8.3 Other Names:\n\nMetacharacters are sometimes referred to as “regex operators” or “special characters.”\nSpecial sequences are also known as “character classes” or “escape sequences.”\n\nUnderstanding metacharacters and special sequences is essential for constructing powerful and flexible regular expressions.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-dot-.-metacharacters",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-dot-.-metacharacters",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.4 The dot (.) metacharacters:",
    "text": "8.4 The dot (.) metacharacters:\nThe dot metacharacter (.) in a regular expression matches any single character except for a newline. It’s often used when you want to represent any character in a pattern. Here’s a simple example:\nimport re\n\npattern = r'c.t'  # Pattern with a dot representing any single character\ntext1 = \"cat\"\ntext2 = \"cot\"\ntext3 = \"coat\"\ntext4 = \"cart\"\ntext5 = \"cut\"\n\nfor text in [text1, text2, text3, text4, text5]:\n    match = re.search(pattern, text)\n    if match:\n        print(f'Pattern \"{pattern}\" found in \"{text}\"')\n    else:\n        print(f'Pattern \"{pattern}\" not found in \"{text}\"')\nIn this example, the pattern 'c.t' consists of: - 'c': The letter ‘c’ at the beginning of the pattern. - '.': The dot metacharacter represents any single character. - 't': The letter ‘t’ at the end of the pattern.\nThe loop goes through different texts and checks if the pattern is found in each of them. The output will be:\nPattern \"c.t\" found in \"cat\"\nPattern \"c.t\" found in \"cot\"\nPattern \"c.t\" found in \"coat\"\nPattern \"c.t\" found in \"cart\"\nPattern \"c.t\" not found in \"cut\"",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-caret-metacharacters",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-caret-metacharacters",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.5 The caret (^) metacharacters:",
    "text": "8.5 The caret (^) metacharacters:\nThe caret (^) metacharacter in a regular expression is an anchor that asserts the start of a line or the start of the string, depending on its position. It indicates that the following pattern must appear at the beginning of the line or string.\nHere’s a simple example to illustrate the use of the caret metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Hello, World!\nThis is a multiline text.\nIt has multiple lines.\n\"\"\"\n\n# Pattern with caret (^) to match lines starting with \"This\"\npattern = r'^This'\n\n# Using re.findall() to find lines starting with \"This\"\nmatches = re.findall(pattern, text, re.MULTILINE | re.IGNORECASE)\n\n# Displaying the matches\nprint(\"Lines starting with 'This':\")\nfor match in matches:\n    print(match)\nIn this example: - The ^This pattern uses the caret metacharacter to match lines that start with the word “This.” - re.MULTILINE flag is used to make the caret match the start of each line within the multiline text.\nThe output will be:\nLines starting with 'This':\nThis is a multiline text.\nHere, the pattern matches the line “This is a multiline text.” because it starts with “This.”\nThe caret metacharacter is particularly useful when you want to ensure that a specific pattern appears at the beginning of a line or the entire string. If you have any further questions or if there’s anything else you’d like to explore, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-dollar-metacharacters",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-dollar-metacharacters",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.6 The dollar ($) metacharacters:",
    "text": "8.6 The dollar ($) metacharacters:\nThe dollar ($) metacharacter in a regular expression is an anchor that asserts the end of a line or the end of the string, depending on its position. It indicates that the preceding pattern must appear at the end of the line or the entire string.\nHere’s a simple example to illustrate the use of the dollar metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Line 1: The price is $50.\nLine 2: The total cost is $120.\nLine 3: The discount is $30.\nLine 4: The final amount is $90.\n\"\"\"\n\n# Pattern with dollar ($) to match lines ending with a sequence of numbers\npattern = r'\\$\\d+$'\n\n# Using re.findall() to find lines ending with a sequence of numbers\nmatches = re.findall(pattern, text, re.MULTILINE)\n\n# Displaying the matches\nprint(\"Lines ending with a sequence of numbers:\")\nfor match in matches:\n    print(match)\nIn this example: - The \\$\\d+$ pattern uses the dollar metacharacter to match lines that end with a sequence of numbers following a dollar sign. - \\$\\d+ specifies a dollar sign followed by one or more digits.\nThe output will be:\nLines ending with a sequence of numbers:\nThe price is $50.\nThe total cost is $120.\nThe discount is $30.\nThe final amount is $90.\nThis pattern ensures that it only matches lines where the content ends with a dollar sign and is immediately followed by one or more digits.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-asterisk-metacharacters",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-asterisk-metacharacters",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.7 The asterisk (*) metacharacters:",
    "text": "8.7 The asterisk (*) metacharacters:",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-dot-.-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-dot-.-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.4 The dot (.) metacharacter:",
    "text": "8.4 The dot (.) metacharacter:\nThe dot metacharacter (.) in a regular expression matches any single character except for a newline. It’s often used when you want to represent any character in a pattern. Here’s a simple example:\nimport re\n\npattern = r'c.t'  # Pattern with a dot representing any single character\ntext1 = \"cat\"\ntext2 = \"cot\"\ntext3 = \"coat\"\ntext4 = \"cart\"\ntext5 = \"cut\"\n\nfor text in [text1, text2, text3, text4, text5]:\n    match = re.search(pattern, text)\n    if match:\n        print(f'Pattern \"{pattern}\" found in \"{text}\"')\n    else:\n        print(f'Pattern \"{pattern}\" not found in \"{text}\"')\nIn this example, the pattern 'c.t' consists of: - 'c': The letter ‘c’ at the beginning of the pattern. - '.': The dot metacharacter represents any single character. - 't': The letter ‘t’ at the end of the pattern.\nThe loop goes through different texts and checks if the pattern is found in each of them. The output will be:\nPattern \"c.t\" found in \"cat\"\nPattern \"c.t\" found in \"cot\"\nPattern \"c.t\" found in \"coat\"\nPattern \"c.t\" found in \"cart\"\nPattern \"c.t\" not found in \"cut\"",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-caret-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-caret-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.5 The caret (^) metacharacter:",
    "text": "8.5 The caret (^) metacharacter:\nThe caret (^) metacharacter in a regular expression is an anchor that asserts the start of a line or the start of the string, depending on its position. It indicates that the following pattern must appear at the beginning of the line or string.\nHere’s a simple example to illustrate the use of the caret metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Hello, World!\nThis is a multiline text.\nIt has multiple lines.\n\"\"\"\n\n# Pattern with caret (^) to match lines starting with \"This\"\npattern = r'^This'\n\n# Using re.findall() to find lines starting with \"This\"\nmatches = re.findall(pattern, text, re.MULTILINE | re.IGNORECASE)\n\n# Displaying the matches\nprint(\"Lines starting with 'This':\")\nfor match in matches:\n    print(match)\nIn this example: - The ^This pattern uses the caret metacharacter to match lines that start with the word “This.” - re.MULTILINE flag is used to make the caret match the start of each line within the multiline text.\nThe output will be:\nLines starting with 'This':\nThis is a multiline text.\nHere, the pattern matches the line “This is a multiline text.” because it starts with “This.”\nThe caret metacharacter is particularly useful when you want to ensure that a specific pattern appears at the beginning of a line or the entire string. If you have any further questions or if there’s anything else you’d like to explore, feel free to let me know!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-dollar-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-dollar-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.6 The dollar ($) metacharacter:",
    "text": "8.6 The dollar ($) metacharacter:\nThe dollar ($) metacharacter in a regular expression is an anchor that asserts the end of a line or the end of the string, depending on its position. It indicates that the preceding pattern must appear at the end of the line or the entire string.\nHere’s a simple example to illustrate the use of the dollar metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Line 1: The price is $50.\nLine 2: The total cost is $120.\nLine 3: The discount is $30.\nLine 4: The final amount is $90.\n\"\"\"\n\n# Pattern with dollar ($) to match lines ending with a sequence of numbers\npattern = r'\\$\\d+$'\n\n# Using re.findall() to find lines ending with a sequence of numbers\nmatches = re.findall(pattern, text, re.MULTILINE)\n\n# Displaying the matches\nprint(\"Lines ending with a sequence of numbers:\")\nfor match in matches:\n    print(match)\nIn this example: - The \\$\\d+$ pattern uses the dollar metacharacter to match lines that end with a sequence of numbers following a dollar sign. - \\$\\d+ specifies a dollar sign followed by one or more digits.\nThe output will be:\nLines ending with a sequence of numbers:\nThe price is $50.\nThe total cost is $120.\nThe discount is $30.\nThe final amount is $90.\nThis pattern ensures that it only matches lines where the content ends with a dollar sign and is immediately followed by one or more digits.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-asterisk-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-asterisk-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.7 The asterisk (*) metacharacter:",
    "text": "8.7 The asterisk (*) metacharacter:\nThe asterisk (*) metacharacter in a regular expression denotes zero or more occurrences of the preceding character or group. It allows for matching patterns with varying lengths of the preceding content, including the case where the preceding content is entirely absent.\nLet’s go through a simple example to illustrate the use of the asterisk metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Hello, World!\nHelllo, World!\nHellllo, World!\n\"\"\"\n\n# Pattern with asterisk (*) to match variations of \"Hello\"\npattern = r'Hell*o'\n\n# Using re.findall() to find variations of \"Hello\"\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Variations of 'Hello' found:\")\nfor match in matches:\n    print(match)\nIn this example: - The Hell*o pattern uses the asterisk metacharacter to match variations of the word “Hello.” - l* allows for zero or more occurrences of the letter ‘l’ in the middle of the pattern.\nThe output will be:\nVariations of 'Hello' found:\nHello\nHelllo\nHellllo\nThe pattern matches variations like “Hello,” “Helllo,” and “Hellllo” by allowing for zero or more ‘l’ characters between ‘Hell’ and ‘o’. The asterisk metacharacter is useful for creating flexible patterns that can accommodate varying lengths of content.w!",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-plus-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-plus-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.8 The plus (+) metacharacter:",
    "text": "8.8 The plus (+) metacharacter:\nThe plus (+) metacharacter in a regular expression denotes one or more occurrences of the preceding character or group. It requires at least one occurrence of the preceding pattern but allows for additional occurrences as well.\nLet’s go through a simple example to illustrate the use of the plus metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"Hello, World!\nHelllo, World!\nHellllo, World!\n\"\"\"\n\n# Pattern with plus (+) to match variations of \"Helllo\"\npattern = r'Hell+o'\n\n# Using re.findall() to find variations of \"Helllo\"\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Variations of 'Helllo' found:\")\nfor match in matches:\n    print(match)\nIn this example: - The Hell+o pattern uses the plus metacharacter to match variations of the word “Helllo.” - l+ requires at least one occurrence of the letter ‘l’ in the middle of the pattern, but it allows for additional occurrences.\nThe output will be:\nVariations of 'Helllo' found:\nHelllo\nHellllo\nThe pattern matches variations like “Helllo” and “Hellllo” by requiring at least one ‘l’ character between ‘Hell’ and ‘o’, but allowing for more if they exist.\nThe plus metacharacter is useful when you want to ensure that there is at least one occurrence of a specific pattern, but you are open to matching more if they are present.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-question-mark-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-question-mark-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.9 The question mark (?) metacharacter:",
    "text": "8.9 The question mark (?) metacharacter:\nThe question mark (?) metacharacter in a regular expression denotes zero or one occurrence of the preceding character or group. It makes the preceding element optional, allowing for flexibility in matching patterns.\nLet’s go through a simple example to illustrate the use of the question mark metacharacter:\nimport re\n\n# Example text\ntext = \"\"\"color\ncolour\n\"\"\"\n\n# Pattern with question mark (?) to match variations of \"color\"\npattern = r'colou?r'\n\n# Using re.findall() to find variations of \"color\"\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Variations of 'color' found:\")\nfor match in matches:\n    print(match)\nIn this example: - The colou?r pattern uses the question mark metacharacter to match variations of the word “color.” - u? makes the letter ‘u’ optional, allowing for both “color” and “colour.”\nThe output will be:\nVariations of 'color' found:\ncolor\ncolour\nThe pattern matches both “color” and “colour” by making the ‘u’ character optional.\nThe question mark metacharacter is useful when you want to indicate that a particular element is optional in the pattern, allowing for different variations of the same word or phrase.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-backslash-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-backslash-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.10 The backslash (\\) metacharacter:",
    "text": "8.10 The backslash (\\) metacharacter:\nThe backslash (\\) metacharacter in a regular expression is used to escape special characters, allowing you to use them as literal characters in the pattern. It can also introduce special sequences representing predefined character classes or special characters.\n\nEscaping Special Characters: \n\nWhen you want to match a character that has a special meaning in regular expressions, you need to use a backslash before that character to indicate that you want to treat it literally. For example:\nimport re\n\n# Example text\ntext = \"The price is $50.\"\n\n# Pattern with escaped dollar sign (\\$) to match the literal dollar sign\npattern = r'\\$50'\n\n# Using re.search() to find the pattern\nmatch = re.search(pattern, text)\n\n# Displaying the match\nprint(\"Match:\", match.group() if match else \"No match\")\nIn this example, the pattern \\$50 is used to match the literal string “$50” in the text.\n\nSpecial Sequences: The backslash can be used to introduce special sequences that represent predefined character classes. For example:\n\nimport re\n\n# Example text\ntext = \"The phone number is 123-456-7890.\"\n\n# Pattern with special sequence (\\d) to match a digit\npattern = r'\\d{3}-\\d{3}-\\d{4}'\n\n# Using re.search() to find the pattern\nmatch = re.search(pattern, text)\n\n# Displaying the match\nprint(\"Match:\", match.group() if match else \"No match\")\nIn this example, the pattern \\d{3}-\\d{3}-\\d{4} uses the special sequence \\d to match three digits, representing a typical phone number format.\nThe backslash is a versatile tool in regular expressions, allowing you to work with special characters and special sequences in a flexible way.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-square-bracket-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-square-bracket-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.11 The square bracket ([]) metacharacter:",
    "text": "8.11 The square bracket ([]) metacharacter:\nThe square bracket ([]) metacharacter in a regular expression is used to define a character class, which is a set of characters that you want to match at a specific position in the pattern. It allows you to specify a range of characters, individual characters, or a combination of both.\n\nExamples of Character Classes:\n\nMatching Individual Characters:\n\nimport re\n\n# Example text\ntext = \"The color of the sky is blue.\"\n\n# Pattern with a character class to match either 'c' or 'l'\npattern = r'[cl]'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['c', 'l', 'l', 'c']\nIn this example, the pattern [cl] matches any occurrence of either ‘c’ or ‘l’ in the text.\n\nMatching a Range of Characters:\n\nimport re\n\n# Example text\ntext = \"The temperature is 25 degrees Celsius.\"\n\n# Pattern with a character class to match any digit (0-9)\npattern = r'[0-9]'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['2', '5']\nHere, the pattern [0-9] matches any digit from 0 to 9 in the text.\n\nNegating a Character Class:\n\nimport re\n\n# Example text\ntext = \"The quick brown fox jumps over the lazy dog.\"\n\n# Pattern with a negated character class to match any character except vowels\npattern = r'[^aeiou]'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['T', 'h', ' ', 'q', 'c', 'k', ' ', 'b', 'r', 'w', 'n', ' ', 'f', 'x', ' ', 'j', 'm', 'p', 's', ' ', 'v', 'r', ' ', 't', 'h', ' ', 'l', 'z', 'y', ' ', 'd', 'g', '.']\nIn this example, the pattern [^aeiou] matches any character except vowels.\nCharacter classes provide a concise way to specify which characters you want to match at a particular position in the pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-character-classes-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-character-classes-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.12 The character classes metacharacter:",
    "text": "8.12 The character classes metacharacter:\nCharacter classes in regular expressions allow you to specify a set of characters that you want to match at a particular position in the pattern. They are defined using square brackets ([]) and provide a concise way to express a group of characters.\nHere is a list of different character classes:\n\n\\d: Matches any digit (equivalent to [0-9]).\n\\D: Matches any non-digit character (equivalent to [^0-9]).\n\\w: Matches any word character (alphanumeric + underscore, equivalent to [A-Za-z0-9_]).\n\\W: Matches any non-word character (equivalent to [^A-Za-z0-9_]).\n\\s: Matches any whitespace character (spaces, tabs, and newlines).\n\\S: Matches any non-whitespace character.\n[a-zA-Z]: Matches any uppercase or lowercase letter.\n[^abc]: Matches any character except ‘a’, ‘b’, or ‘c’.\n\n\nExamples of Character Classes:\n\nMatching Digits:\n\nimport re\n\n# Example text\ntext = \"The price is $25.99.\"\n\n# Pattern with a character class to match any digit (0-9)\npattern = r'\\d'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['2', '5', '9', '9']\nIn this example, the pattern \\d is a shorthand for the character class [0-9] and matches any digit.\n\nMatching Alphanumeric Characters:\n\nimport re\n\n# Example text\ntext = \"The account ID is A1234B.\"\n\n# Pattern with a character class to match alphanumeric characters\npattern = r'[A-Za-z0-9]'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['T', 'h', 'e', 'a', 'c', 'c', 'o', 'u', 'n', 't', 'I', 'D', 'i', 's', 'A', '1', '2', '3', '4', 'B']\nHere, the pattern [A-Za-z0-9] matches any uppercase letter, lowercase letter, or digit.\n\nMatching Whitespace Characters:\n\nimport re\n\n# Example text\ntext = \"This is a sentence with some spaces.\"\n\n# Pattern with a character class to match whitespace characters\npattern = r'\\s'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: [' ', ' ', ' ', ' ', ' ']\nIn this example, the pattern \\s matches any whitespace character (spaces).\nCharacter classes are versatile and allow you to specify groups of characters that you want to match at a specific position in your regular expression pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-curly-braces-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-curly-braces-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.13 The curly braces ({}) metacharacter:",
    "text": "8.13 The curly braces ({}) metacharacter:\nThe curly braces ({}) in a regular expression are used as quantifiers to specify the exact number of occurrences or a range of occurrences of the preceding character or group.\n\nExamples of Using Curly Braces:\n\nMatching a Specific Number of Occurrences:\n\nimport re\n\n# Example text\ntext = \"The number is 12345.\"\n\n# Pattern to match exactly 5 digits\npattern = r'\\d{5}'\n\n# Using re.search() to find the pattern\nmatch = re.search(pattern, text)\n\n# Displaying the match\nprint(\"Match:\", match.group() if match else \"No match\")\nOutput:\nMatch: 12345\nIn this example, the pattern \\d{5} matches exactly 5 consecutive digits in the text.\n\nMatching a Range of Occurrences:\n\nimport re\n\n# Example text\ntext = \"The price is $25.99.\"\n\n# Pattern to match 2 to 4 digits\npattern = r'\\d{2,4}'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['25', '99']\nHere, the pattern \\d{2,4} matches a sequence of 2 to 4 digits.\n\nGreedy vs. Non-Greedy Quantifiers:\n\nimport re\n\n# Example text\ntext = \"abcddddd\"\n\n# Greedy quantifier (matches as much as possible)\ngreedy_pattern = r'ab.{2,4}d'\n\n# Non-greedy quantifier (matches as little as possible)\nnon_greedy_pattern = r'ab.{2,4}?d'\n\n# Using re.search() to find matches\ngreedy_match = re.search(greedy_pattern, text)\nnon_greedy_match = re.search(non_greedy_pattern, text)\n\n# Displaying the matches\nprint(\"Greedy Match:\", greedy_match.group() if greedy_match else \"No match\")\nprint(\"Non-Greedy Match:\", non_greedy_match.group() if non_greedy_match else \"No match\")\nOutput:\nGreedy Match: abcd\nNon-Greedy Match: abc\nHere, the greedy quantifier {2,4} tries to match as much as possible, while the non-greedy quantifier {2,4}? matches as little as possible.\nCurly braces provide a precise way to control the number of occurrences in a regular expression pattern.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#the-pipe-metacharacter",
    "href": "2. Regular Expressions/2. regex metacharacters.html#the-pipe-metacharacter",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.14 The pipe (|) metacharacter:",
    "text": "8.14 The pipe (|) metacharacter:\nThe pipe (|) metacharacter in a regular expression serves as an alternation operator. It allows you to specify multiple alternative patterns, and the expression will match if any of those patterns are found. It essentially functions as a logical OR.\n\nExample:\n\nimport re\n\n# Example text\ntext = \"The cat is black and the dog is brown.\"\n\n# Pattern to match either \"cat\" or \"dog\"\npattern = r'cat|dog'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['cat', 'dog']\nIn this example, the pattern cat|dog uses the pipe metacharacter to match either “cat” or “dog” in the given text. The alternation operator allows for flexibility in matching different alternatives within the same pattern.\nYou can extend the alternation to include more options:\nimport re\n\n# Example text\ntext = \"The cat is black and the dog is brown.\"\n\n# Pattern to match either \"cat\", \"dog\", or \"black\"\npattern = r'cat|dog|black'\n\n# Using re.findall() to find matches\nmatches = re.findall(pattern, text)\n\n# Displaying the matches\nprint(\"Matches:\", matches)\nOutput:\nMatches: ['cat', 'dog', 'black']\nHere, the pattern includes three alternatives: “cat,” “dog,” or “black.” The alternation operator makes it possible to match any of these options.\nThe pipe metacharacter is useful for creating more flexible and inclusive patterns when you want to match different possibilities at a specific position in the text.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  },
  {
    "objectID": "2. Regular Expressions/2. regex metacharacters.html#greedy-vs-non-greedy-quantifiers",
    "href": "2. Regular Expressions/2. regex metacharacters.html#greedy-vs-non-greedy-quantifiers",
    "title": "8  Metacharacters & Special Sequences",
    "section": "8.15 Greedy vs Non-Greedy Quantifiers:",
    "text": "8.15 Greedy vs Non-Greedy Quantifiers:\nIn regular expressions, the terms “greedy” and “non-greedy” refer to the behavior of quantifiers when determining how much of the input string they should match. Quantifiers are metacharacters that specify the number of occurrences of the preceding character or group.\n\nGreedy Quantifiers:\nGreedy quantifiers match as much of the input string as possible while still allowing the entire pattern to match.\nGreedy quantifiers include * (asterisk), + (plus), and ? (question mark).\nNon-Greedy (or Lazy) Quantifiers:\nNon-greedy quantifiers match as little of the input string as possible while still allowing the entire pattern to match.\nNon-greedy quantifiers are obtained by adding an extra ? after a greedy quantifier (*?, +?, ??).\nExample: Let’s consider an example using a greedy quantifier (*) and a non-greedy quantifier (*?):\n\nimport re\n\n# Example text\ntext = \"This is a sample &lt;b&gt;greedy&lt;/b&gt; example &lt;b&gt;non-greedy&lt;/b&gt;.\"\n\n# Greedy quantifier (matches as much as possible)\ngreedy_pattern = r'&lt;b&gt;.*&lt;/b&gt;'\n\n# Non-greedy quantifier (matches as little as possible)\nnon_greedy_pattern = r'&lt;b&gt;.*?&lt;/b&gt;'\n\n# Using re.search() to find matches\ngreedy_match = re.search(greedy_pattern, text)\nnon_greedy_match = re.search(non_greedy_pattern, text)\n\n# Displaying the matches\nprint(\"Greedy Match:\", greedy_match.group() if greedy_match else \"No match\")\nprint(\"Non-Greedy Match:\", non_greedy_match.group() if non_greedy_match else \"No match\")\nIn this example: - The greedy pattern &lt;b&gt;.*&lt;/b&gt; aims to match everything between the first &lt;b&gt; and the last &lt;/b&gt;. - The non-greedy pattern &lt;b&gt;.*?&lt;/b&gt; aims to match the smallest possible content between &lt;b&gt; and &lt;/b&gt;.\nThe output will be:\nGreedy Match: &lt;b&gt;greedy&lt;/b&gt; example &lt;b&gt;non-greedy&lt;/b&gt;\nNon-Greedy Match: &lt;b&gt;greedy&lt;/b&gt;\nAs you can see, the greedy quantifier matches as much as possible, capturing everything between the first &lt;b&gt; and the last &lt;/b&gt;. On the other hand, the non-greedy quantifier captures the smallest possible content, stopping at the first &lt;/b&gt;.\nUnderstanding the difference between greedy and non-greedy quantifiers is crucial when working with regular expressions, especially in scenarios where you want to control the extent of the match.",
    "crumbs": [
      "Automation with Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Metacharacters & Special Sequences</span>"
    ]
  }
]